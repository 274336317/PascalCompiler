/**
 * generated by Xtext
 */
package org.xtext.example.pascal.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.pascal.pascal.PascalFactory;
import org.xtext.example.pascal.pascal.PascalPackage;
import org.xtext.example.pascal.pascal.abstraction_declaration;
import org.xtext.example.pascal.pascal.abstraction_heading;
import org.xtext.example.pascal.pascal.any_number;
import org.xtext.example.pascal.pascal.array_type;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.case_label_list;
import org.xtext.example.pascal.pascal.case_limb;
import org.xtext.example.pascal.pascal.case_statement;
import org.xtext.example.pascal.pascal.compound_statement;
import org.xtext.example.pascal.pascal.conditional_statement;
import org.xtext.example.pascal.pascal.conformant_array_schema;
import org.xtext.example.pascal.pascal.constant;
import org.xtext.example.pascal.pascal.constant_definition;
import org.xtext.example.pascal.pascal.constant_definition_part;
import org.xtext.example.pascal.pascal.dynamic_array_type;
import org.xtext.example.pascal.pascal.enumerated_type;
import org.xtext.example.pascal.pascal.expression;
import org.xtext.example.pascal.pascal.expression_list;
import org.xtext.example.pascal.pascal.factor;
import org.xtext.example.pascal.pascal.file_type;
import org.xtext.example.pascal.pascal.for_statement;
import org.xtext.example.pascal.pascal.formal_parameter_list;
import org.xtext.example.pascal.pascal.formal_parameter_section;
import org.xtext.example.pascal.pascal.function_designator;
import org.xtext.example.pascal.pascal.identifier_list;
import org.xtext.example.pascal.pascal.if_statement;
import org.xtext.example.pascal.pascal.number;
import org.xtext.example.pascal.pascal.packed_conformant_array_schema;
import org.xtext.example.pascal.pascal.parameter_type;
import org.xtext.example.pascal.pascal.pointer_type;
import org.xtext.example.pascal.pascal.procedure_and_function_declaration_part;
import org.xtext.example.pascal.pascal.record_type;
import org.xtext.example.pascal.pascal.repeat_statement;
import org.xtext.example.pascal.pascal.repetitive_statement;
import org.xtext.example.pascal.pascal.set;
import org.xtext.example.pascal.pascal.set_type;
import org.xtext.example.pascal.pascal.simple_expression;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.simple_type;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_part;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.structured_statement;
import org.xtext.example.pascal.pascal.structured_type;
import org.xtext.example.pascal.pascal.subrange_type;
import org.xtext.example.pascal.pascal.term;
import org.xtext.example.pascal.pascal.type;
import org.xtext.example.pascal.pascal.unpacked_conformant_array_schema;
import org.xtext.example.pascal.pascal.unpacked_structured_type;
import org.xtext.example.pascal.pascal.value_parameter_section;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.pascal.variable_declaration_part;
import org.xtext.example.pascal.pascal.variable_identifier_list;
import org.xtext.example.pascal.pascal.variable_parameter_section;
import org.xtext.example.pascal.pascal.variable_section;
import org.xtext.example.pascal.pascal.while_statement;
import org.xtext.example.pascal.pascal.with_statement;
import org.xtext.example.pascal.validation.AbstractPascalValidator;
import org.xtext.example.pascal.validation.Element;
import org.xtext.example.pascal.validation.ElementType;
import org.xtext.example.pascal.validation.ErrorType;
import org.xtext.example.pascal.validation.Function;
import org.xtext.example.pascal.validation.Procedure;
import org.xtext.example.pascal.validation.Type;
import org.xtext.example.pascal.validation.TypeInferer;
import org.xtext.example.pascal.validation.Variable;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class PascalValidator extends AbstractPascalValidator {
  private Map<EObject, Set<org.xtext.example.pascal.validation.Error>> errorList = new HashMap<EObject, Set<org.xtext.example.pascal.validation.Error>>();
  
  private Map<block, Set<Variable>> variables = new HashMap<block, Set<Variable>>();
  
  private Map<block, Set<Procedure>> abstractions = new HashMap<block, Set<Procedure>>();
  
  private Map<block, Set<Type>> types = new HashMap<block, Set<Type>>();
  
  private Set<Procedure> standardAbstractions = new HashSet<Procedure>();
  
  private Set<Type> standardTypes = new HashSet<Type>();
  
  public HashSet<Variable> getParameters(final String... vars) {
    HashSet<Variable> variables = new HashSet<Variable>();
    int count = 0;
    for (final String type : vars) {
      {
        Variable _variable = new Variable(("arg_" + Integer.valueOf(count)), type, false, ElementType.PARAMETER);
        variables.add(_variable);
        count++;
      }
    }
    HashSet<Variable> parameters = new HashSet<Variable>(variables);
    return parameters;
  }
  
  public <T extends Object> ArrayList<T> replaceListElement(final List<T> list, final int index, final T newElement) {
    ArrayList<T> newList = new ArrayList<T>(list);
    newList.remove(index);
    newList.add(index, newElement);
    return newList;
  }
  
  public void addAbstraction(final Set<Procedure> abstractions, final String name, final String returnType, final String... parameters) {
    List<String> virtualParameters = IterableExtensions.<String>toList(((Iterable<String>)Conversions.doWrapArray(parameters)));
    boolean isVirtual = false;
    for (int i = 0; (i < virtualParameters.size()); i++) {
      String _get = virtualParameters.get(i);
      boolean _equals = Objects.equal(_get, "numeric");
      if (_equals) {
        ArrayList<String> _replaceListElement = this.<String>replaceListElement(virtualParameters, i, "integer");
        this.addAbstraction(abstractions, name, returnType, ((String[])Conversions.unwrapArray(_replaceListElement, String.class)));
        ArrayList<String> _replaceListElement_1 = this.<String>replaceListElement(virtualParameters, i, "real");
        this.addAbstraction(abstractions, name, returnType, ((String[])Conversions.unwrapArray(_replaceListElement_1, String.class)));
        isVirtual = true;
      }
    }
    if ((!isVirtual)) {
      boolean _equals = Objects.equal(returnType, "reflect");
      if (_equals) {
        int _length = parameters.length;
        boolean _equals_1 = (_length == 1);
        if (_equals_1) {
          HashSet<Variable> _parameters = this.getParameters(parameters);
          List<String> _list = IterableExtensions.<String>toList(((Iterable<String>)Conversions.doWrapArray(parameters)));
          String _get = _list.get(0);
          Function _function = new Function(name, true, _parameters, false, _get);
          abstractions.add(_function);
        } else {
          throw new RuntimeException("Invalid return type");
        }
      } else {
        boolean _equals_2 = Objects.equal(returnType, "void");
        if (_equals_2) {
          HashSet<Variable> _parameters_1 = this.getParameters(parameters);
          Procedure _procedure = new Procedure(name, false, _parameters_1, false);
          abstractions.add(_procedure);
        } else {
          HashSet<Variable> _parameters_2 = this.getParameters(parameters);
          Function _function_1 = new Function(name, false, _parameters_2, false, returnType);
          abstractions.add(_function_1);
        }
      }
    }
  }
  
  public void setStandardAbstractions(final Set<Procedure> it) {
    this.addAbstraction(it, "round", "integer", "real");
    this.addAbstraction(it, "chr", "char", "integer");
    this.addAbstraction(it, "abs", "reflect", "numeric");
    this.addAbstraction(it, "odd", "boolean", "integer");
    this.addAbstraction(it, "sqr", "reflect", "numeric");
    this.addAbstraction(it, "sqrt", "real", "numeric");
    this.addAbstraction(it, "sin", "real", "numeric");
    this.addAbstraction(it, "cos", "real", "numeric");
    this.addAbstraction(it, "arctan", "real", "numeric");
    this.addAbstraction(it, "ln", "real", "numeric");
    this.addAbstraction(it, "exp", "real", "numeric");
    this.addAbstraction(it, "succ", "...enumerated", "...enumerated");
    this.addAbstraction(it, "succ", "integer", "integer");
    this.addAbstraction(it, "pred", "...enumerated", "...enumerated");
    this.addAbstraction(it, "pred", "integer", "integer");
    this.addAbstraction(it, "new", "void", "^?");
    this.addAbstraction(it, "dispose", "void", "^?");
    this.addAbstraction(it, "strconcat", "void", "packed array of char", "packed array of char");
    this.addAbstraction(it, "strdelete", "void", "packed array of char", "integer", "integer");
    this.addAbstraction(it, "strinsert", "void", "packed array of char", "packed array of char", "integer");
    this.addAbstraction(it, "strlen", "integer", "packed array of char");
    this.addAbstraction(it, "strscan", "integer", "packed array of char", "packed array of char");
    this.addAbstraction(it, "strlen", "integer", "packed array of char");
    this.addAbstraction(it, "substr", "void", "packed array of char", "integer", "integer", "packed array of char");
    this.addAbstraction(it, "address", "integer", "^?");
    this.addAbstraction(it, "length", "integer", "[]?");
    this.addAbstraction(it, "setlength", "void", "[]?", "integer");
    this.addAbstraction(it, "write", "void", "?");
    this.addAbstraction(it, "writeln", "void", "?");
    this.addAbstraction(it, "read", "void", "file", "?");
    this.addAbstraction(it, "readln", "void", "file", "?");
  }
  
  public Set<Procedure> getStandardAbstractions() {
    boolean _isEmpty = this.standardAbstractions.isEmpty();
    if (_isEmpty) {
      this.setStandardAbstractions(this.standardAbstractions);
    }
    return this.standardAbstractions;
  }
  
  public Set<Type> getStandardTypes() {
    boolean _isEmpty = this.standardTypes.isEmpty();
    if (_isEmpty) {
      Type _type = new Type("real", false);
      this.standardTypes.add(_type);
      Type _type_1 = new Type("integer", false);
      this.standardTypes.add(_type_1);
      Type _type_2 = new Type("shortint", false);
      this.standardTypes.add(_type_2);
      Type _type_3 = new Type("longint", false);
      this.standardTypes.add(_type_3);
      Type _type_4 = new Type("boolean", false);
      this.standardTypes.add(_type_4);
      Type _type_5 = new Type("char", false);
      this.standardTypes.add(_type_5);
    }
    return this.standardTypes;
  }
  
  public <T extends Element> T search(final Set<T> elements, final T key) {
    for (final T t : elements) {
      boolean _equals = t.equals(key);
      if (_equals) {
        return t;
      }
    }
    return null;
  }
  
  public Procedure searchWithTypeCoersion(final Set<Procedure> elements, final Procedure key) {
    Procedure optimal = null;
    for (final Procedure t : elements) {
      {
        boolean _equals = t.equals(key);
        if (_equals) {
          return t;
        }
        boolean _equalsWithTypeCoersion = t.equalsWithTypeCoersion(key);
        if (_equalsWithTypeCoersion) {
          optimal = t;
        }
      }
    }
    return optimal;
  }
  
  public boolean insertError(final EObject object, final String message, final ErrorType type, final EStructuralFeature feature) {
    boolean _xblockexpression = false;
    {
      boolean _containsKey = this.errorList.containsKey(object);
      boolean _not = (!_containsKey);
      if (_not) {
        HashSet<org.xtext.example.pascal.validation.Error> _hashSet = new HashSet<org.xtext.example.pascal.validation.Error>();
        this.errorList.put(object, _hashSet);
      }
      Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(object);
      org.xtext.example.pascal.validation.Error _error = new org.xtext.example.pascal.validation.Error(message, type, feature);
      _xblockexpression = _get.add(_error);
    }
    return _xblockexpression;
  }
  
  public void removeError(final EObject object, final ErrorType type) {
    boolean _containsKey = this.errorList.containsKey(object);
    boolean _not = (!_containsKey);
    if (_not) {
      HashSet<org.xtext.example.pascal.validation.Error> _hashSet = new HashSet<org.xtext.example.pascal.validation.Error>();
      this.errorList.put(object, _hashSet);
    }
    Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(object);
    org.xtext.example.pascal.validation.Error _error = new org.xtext.example.pascal.validation.Error(type);
    _get.remove(_error);
    this.showError(object);
  }
  
  public <T extends Element> boolean clear(final block b, final ElementType type, final Map<block, Set<T>> container) {
    boolean _xblockexpression = false;
    {
      boolean _containsKey = container.containsKey(b);
      boolean _not = (!_containsKey);
      if (_not) {
        HashSet<T> _hashSet = new HashSet<T>();
        container.put(b, _hashSet);
      } else {
        HashSet<T> newSet = new HashSet<T>();
        Set<T> _get = container.get(b);
        for (final T t : _get) {
          boolean _or = false;
          boolean _notEquals = (!Objects.equal(t.type, type));
          if (_notEquals) {
            _or = true;
          } else {
            boolean _isInherited = t.isInherited();
            _or = _isInherited;
          }
          if (_or) {
            newSet.add(t);
          }
        }
        container.put(b, newSet);
      }
      boolean _xifexpression = false;
      boolean _equals = Objects.equal(container, this.abstractions);
      if (_equals) {
        Set<Procedure> _get_1 = this.abstractions.get(b);
        Set<Procedure> _standardAbstractions = this.getStandardAbstractions();
        _xifexpression = _get_1.addAll(_standardAbstractions);
      } else {
        boolean _xifexpression_1 = false;
        boolean _equals_1 = Objects.equal(container, this.types);
        if (_equals_1) {
          Set<Type> _get_2 = this.types.get(b);
          Set<Type> _standardTypes = this.getStandardTypes();
          _xifexpression_1 = _get_2.addAll(_standardTypes);
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public HashSet<Variable> getParameters(final block b, final function_designator f) {
    HashSet<Variable> parameters = new HashSet<Variable>();
    expression_list _expressions = f.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      int count = 0;
      expression_list _expressions_1 = f.getExpressions();
      EList<expression> _expressions_2 = _expressions_1.getExpressions();
      for (final expression e : _expressions_2) {
        {
          String _type = this.getType(b, e);
          Variable _variable = new Variable(("arg_" + Integer.valueOf(count)), _type, false, ElementType.PARAMETER);
          parameters.add(_variable);
          count++;
        }
      }
    }
    return parameters;
  }
  
  public Procedure getAbstraction(final block b, final function_designator f) {
    String name = f.getName();
    HashSet<Variable> parameters = this.getParameters(b, f);
    return new Procedure(name, parameters);
  }
  
  public String getType(final type t) {
    simple_type _simple = t.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_type simple = t.getSimple();
      boolean _or = false;
      subrange_type _subrange = simple.getSubrange();
      boolean _notEquals_1 = (!Objects.equal(_subrange, null));
      if (_notEquals_1) {
        _or = true;
      } else {
        enumerated_type _enumerated = simple.getEnumerated();
        boolean _notEquals_2 = (!Objects.equal(_enumerated, null));
        _or = _notEquals_2;
      }
      if (_or) {
        return "...enumerated";
      } else {
        String _name = simple.getName();
        boolean _notEquals_3 = (!Objects.equal(_name, null));
        if (_notEquals_3) {
          return simple.getName();
        }
      }
    } else {
      structured_type _structured = t.getStructured();
      boolean _notEquals_4 = (!Objects.equal(_structured, null));
      if (_notEquals_4) {
        String syntetizedType = "";
        structured_type structured = t.getStructured();
        boolean _isPacked = structured.isPacked();
        if (_isPacked) {
          String _syntetizedType = syntetizedType;
          syntetizedType = (_syntetizedType + "packed ");
        }
        unpacked_structured_type unpacked = structured.getType();
        array_type _array = unpacked.getArray();
        boolean _notEquals_5 = (!Objects.equal(_array, null));
        if (_notEquals_5) {
          String _syntetizedType_1 = syntetizedType;
          array_type _array_1 = unpacked.getArray();
          type _type = _array_1.getType();
          String _type_1 = this.getType(_type);
          String _plus = ("array of " + _type_1);
          syntetizedType = (_syntetizedType_1 + _plus);
        } else {
          dynamic_array_type _dynamic = unpacked.getDynamic();
          boolean _notEquals_6 = (!Objects.equal(_dynamic, null));
          if (_notEquals_6) {
            String _syntetizedType_2 = syntetizedType;
            dynamic_array_type _dynamic_1 = unpacked.getDynamic();
            type _type_2 = _dynamic_1.getType();
            String _type_3 = this.getType(_type_2);
            String _plus_1 = ("array of " + _type_3);
            syntetizedType = (_syntetizedType_2 + _plus_1);
          } else {
            record_type _record = unpacked.getRecord();
            boolean _notEquals_7 = (!Objects.equal(_record, null));
            if (_notEquals_7) {
              String _syntetizedType_3 = syntetizedType;
              syntetizedType = (_syntetizedType_3 + "record");
            } else {
              set_type _set = unpacked.getSet();
              boolean _notEquals_8 = (!Objects.equal(_set, null));
              if (_notEquals_8) {
                String _syntetizedType_4 = syntetizedType;
                set_type _set_1 = unpacked.getSet();
                type _type_4 = _set_1.getType();
                String _type_5 = this.getType(_type_4);
                String _plus_2 = ("set of " + _type_5);
                syntetizedType = (_syntetizedType_4 + _plus_2);
              } else {
                file_type _file = unpacked.getFile();
                boolean _notEquals_9 = (!Objects.equal(_file, null));
                if (_notEquals_9) {
                  String _syntetizedType_5 = syntetizedType;
                  file_type _file_1 = unpacked.getFile();
                  type _type_6 = _file_1.getType();
                  String _type_7 = this.getType(_type_6);
                  String _plus_3 = ("file of " + _type_7);
                  syntetizedType = (_syntetizedType_5 + _plus_3);
                }
              }
            }
          }
        }
        return syntetizedType;
      } else {
        pointer_type _pointer = t.getPointer();
        boolean _notEquals_10 = (!Objects.equal(_pointer, null));
        if (_notEquals_10) {
          pointer_type _pointer_1 = t.getPointer();
          type _type_8 = _pointer_1.getType();
          String _type_9 = this.getType(_type_8);
          return ("^" + _type_9);
        }
      }
    }
    return null;
  }
  
  public String getType(final parameter_type type) {
    conformant_array_schema _array = type.getArray();
    boolean _notEquals = (!Objects.equal(_array, null));
    if (_notEquals) {
      conformant_array_schema array = type.getArray();
      packed_conformant_array_schema _packed = array.getPacked();
      boolean _notEquals_1 = (!Objects.equal(_packed, null));
      if (_notEquals_1) {
        packed_conformant_array_schema _packed_1 = array.getPacked();
        String _name = _packed_1.getName();
        return ("packed array of " + _name);
      } else {
        unpacked_conformant_array_schema _unpacked = array.getUnpacked();
        boolean _notEquals_2 = (!Objects.equal(_unpacked, null));
        if (_notEquals_2) {
          unpacked_conformant_array_schema _unpacked_1 = array.getUnpacked();
          parameter_type _type = _unpacked_1.getType();
          String _type_1 = this.getType(_type);
          return ("array of " + _type_1);
        }
      }
    } else {
      String _name_1 = type.getName();
      boolean _notEquals_3 = (!Objects.equal(_name_1, null));
      if (_notEquals_3) {
        return type.getName();
      }
    }
    return null;
  }
  
  public String getType(final block b, final variable v) {
    Set<Variable> _get = this.variables.get(b);
    String _name = v.getName();
    Variable _variable = new Variable(_name);
    Variable variableFound = this.<Variable>search(_get, _variable);
    boolean _notEquals = (!Objects.equal(variableFound, null));
    if (_notEquals) {
      return variableFound.getVarType();
    }
    return null;
  }
  
  public String getType(final block b, final function_designator f) {
    Procedure function = this.getAbstraction(b, f);
    Set<Procedure> _get = this.abstractions.get(b);
    Procedure abstractionFound = this.<Procedure>search(_get, function);
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(abstractionFound, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _equals = Objects.equal(abstractionFound.type, ElementType.FUNCTION);
      _and = _equals;
    }
    if (_and) {
      Function functionFound = ((Function) abstractionFound);
      return functionFound.getReturnType();
    }
    return null;
  }
  
  public String getType(final block b, final factor f) {
    variable _variable = f.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      variable _variable_1 = f.getVariable();
      return this.getType(b, _variable_1);
    } else {
      number _number = f.getNumber();
      boolean _notEquals_1 = (!Objects.equal(_number, null));
      if (_notEquals_1) {
        number _number_1 = f.getNumber();
        any_number number = _number_1.getNumber();
        String _integer = number.getInteger();
        boolean _notEquals_2 = (!Objects.equal(_integer, null));
        if (_notEquals_2) {
          return "integer";
        } else {
          String _real = number.getReal();
          boolean _notEquals_3 = (!Objects.equal(_real, null));
          if (_notEquals_3) {
            return "real";
          }
        }
      } else {
        String _string = f.getString();
        boolean _notEquals_4 = (!Objects.equal(_string, null));
        if (_notEquals_4) {
          return "packed array of char";
        } else {
          set _set = f.getSet();
          boolean _notEquals_5 = (!Objects.equal(_set, null));
          if (_notEquals_5) {
            set _set_1 = f.getSet();
            expression_list _expressions = _set_1.getExpressions();
            return this.getType(b, _expressions);
          } else {
            boolean _isNil = f.isNil();
            if (_isNil) {
              return "nil";
            } else {
              boolean _or = false;
              String _boolean = f.getBoolean();
              boolean _notEquals_6 = (!Objects.equal(_boolean, null));
              if (_notEquals_6) {
                _or = true;
              } else {
                factor _not = f.getNot();
                boolean _notEquals_7 = (!Objects.equal(_not, null));
                _or = _notEquals_7;
              }
              if (_or) {
                return "boolean";
              } else {
                function_designator _function = f.getFunction();
                boolean _notEquals_8 = (!Objects.equal(_function, null));
                if (_notEquals_8) {
                  function_designator _function_1 = f.getFunction();
                  return this.getType(b, _function_1);
                } else {
                  expression _expression = f.getExpression();
                  boolean _notEquals_9 = (!Objects.equal(_expression, null));
                  if (_notEquals_9) {
                    expression _expression_1 = f.getExpression();
                    return this.getType(b, _expression_1);
                  }
                }
              }
            }
          }
        }
      }
    }
    return null;
  }
  
  public String getType(final block b, final term t) {
    String greatestType = "";
    EList<factor> _factors = t.getFactors();
    for (final factor f : _factors) {
      {
        String type = this.getType(b, f);
        String _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    return greatestType;
  }
  
  public String getType(final block b, final simple_expression expr) {
    String greatestType = "";
    EList<term> _terms = expr.getTerms();
    for (final term t : _terms) {
      {
        String type = this.getType(b, t);
        String _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    return greatestType;
  }
  
  public String getType(final block b, final expression expr) {
    String greatestType = "";
    EList<simple_expression> _expressions = expr.getExpressions();
    for (final simple_expression e : _expressions) {
      {
        String type = this.getType(b, e);
        String _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    return greatestType;
  }
  
  public String getType(final block b, final expression_list expr) {
    String greatestType = "";
    EList<expression> _expressions = expr.getExpressions();
    for (final expression e : _expressions) {
      {
        String type = this.getType(b, e);
        String _greater = TypeInferer.greater(type, greatestType);
        greatestType = _greater;
      }
    }
    return greatestType;
  }
  
  public <T extends Element> boolean addElementToAbstraction(final abstraction_declaration decl, final T element, final Map<block, Set<T>> container) {
    boolean _xblockexpression = false;
    {
      block _block = decl.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        PascalFactory _pascalFactory = PascalPackage.eINSTANCE.getPascalFactory();
        block _createblock = _pascalFactory.createblock();
        decl.setBlock(_createblock);
      }
      block subblock = decl.getBlock();
      boolean _containsKey = container.containsKey(subblock);
      boolean _not = (!_containsKey);
      if (_not) {
        HashSet<T> _hashSet = new HashSet<T>();
        container.put(subblock, _hashSet);
      }
      Set<T> _get = container.get(subblock);
      _xblockexpression = _get.add(element);
    }
    return _xblockexpression;
  }
  
  public <T extends Element> void inheritElement(final block b, final T element, final Map<block, Set<T>> container) {
    procedure_and_function_declaration_part _abstraction = b.getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      procedure_and_function_declaration_part _abstraction_1 = b.getAbstraction();
      EList<abstraction_heading> _procedures = _abstraction_1.getProcedures();
      boolean _notEquals_1 = (!Objects.equal(_procedures, null));
      if (_notEquals_1) {
        procedure_and_function_declaration_part _abstraction_2 = b.getAbstraction();
        EList<abstraction_heading> _procedures_1 = _abstraction_2.getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          this.<T>addElementToAbstraction(procedure, element, container);
        }
      }
      procedure_and_function_declaration_part _abstraction_3 = b.getAbstraction();
      EList<abstraction_declaration> _functions = _abstraction_3.getFunctions();
      boolean _notEquals_2 = (!Objects.equal(_functions, null));
      if (_notEquals_2) {
        procedure_and_function_declaration_part _abstraction_4 = b.getAbstraction();
        EList<abstraction_declaration> _functions_1 = _abstraction_4.getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          {
            this.<T>addElementToAbstraction(function, element, container);
            boolean _equals = Objects.equal(container, this.variables);
            if (_equals) {
              block _block = function.getBlock();
              Set<Variable> _get = this.variables.get(_block);
              abstraction_heading _heading = function.getHeading();
              String _name = _heading.getName();
              abstraction_heading _heading_1 = function.getHeading();
              String _returnType = _heading_1.getReturnType();
              Variable _variable = new Variable(_name, _returnType, false, ElementType.FUNCTION_RETURN);
              _get.add(_variable);
            }
          }
        }
      }
    }
  }
  
  public <T extends Element> Boolean addElement(final block b, final T element, final Map<block, Set<T>> container, final EObject errorSection, final EStructuralFeature errorFeature) {
    boolean _xblockexpression = false;
    {
      Set<T> _get = container.get(b);
      T elementFound = this.<T>search(_get, element);
      boolean _xifexpression = false;
      boolean _and = false;
      boolean _notEquals = (!Objects.equal(elementFound, null));
      if (!_notEquals) {
        _and = false;
      } else {
        boolean _isInherited = elementFound.isInherited();
        boolean _not = (!_isInherited);
        _and = _not;
      }
      if (_and) {
        boolean _xifexpression_1 = false;
        boolean _equals = Objects.equal(element.type, elementFound.type);
        if (_equals) {
          String _plus = (element.type + " cannot be redeclared.");
          _xifexpression_1 = this.insertError(errorSection, _plus, ErrorType.REDECLARATION, errorFeature);
        } else {
          boolean _xifexpression_2 = false;
          boolean _equals_1 = Objects.equal(elementFound.type, ElementType.FUNCTION_RETURN);
          if (_equals_1) {
            _xifexpression_2 = this.insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
          } else {
            String _string = elementFound.type.toString();
            String _lowerCase = _string.toLowerCase();
            String _plus_1 = ("Identifier is already being used by a " + _lowerCase);
            String _plus_2 = (_plus_1 + ".");
            _xifexpression_2 = this.insertError(errorSection, _plus_2, ErrorType.REDECLARATION, errorFeature);
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      } else {
        this.removeError(errorSection, ErrorType.REDECLARATION);
        Set<T> _get_1 = container.get(b);
        _get_1.remove(elementFound);
        Set<T> _get_2 = container.get(b);
        _get_2.add(element);
        Element _clone = element.clone();
        T inheritedElement = ((T) _clone);
        inheritedElement.inherited = true;
        this.<T>inheritElement(b, inheritedElement, container);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  public HashSet<Variable> getParameters(final block b, final abstraction_heading heading) {
    HashSet<Variable> parameters = new HashSet<Variable>();
    formal_parameter_list _parameters = heading.getParameters();
    boolean _notEquals = (!Objects.equal(_parameters, null));
    if (_notEquals) {
      formal_parameter_list list = heading.getParameters();
      EList<formal_parameter_section> _parameters_1 = list.getParameters();
      boolean _notEquals_1 = (!Objects.equal(_parameters_1, null));
      if (_notEquals_1) {
        EList<formal_parameter_section> _parameters_2 = list.getParameters();
        for (final formal_parameter_section section : _parameters_2) {
          variable_parameter_section _variable = section.getVariable();
          boolean _notEquals_2 = (!Objects.equal(_variable, null));
          if (_notEquals_2) {
            variable_parameter_section variable = section.getVariable();
            identifier_list _identifiers = variable.getIdentifiers();
            EList<String> _names = _identifiers.getNames();
            for (final String varName : _names) {
              {
                variable_parameter_section _variable_1 = section.getVariable();
                parameter_type _type = _variable_1.getType();
                String _type_1 = this.getType(_type);
                Variable parameter = new Variable(varName, _type_1, false, ElementType.PARAMETER);
                this.<Variable>addElement(b, parameter, this.variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
                parameters.add(parameter);
              }
            }
          } else {
            value_parameter_section _value = section.getValue();
            boolean _notEquals_3 = (!Objects.equal(_value, null));
            if (_notEquals_3) {
              value_parameter_section value = section.getValue();
              identifier_list _identifiers_1 = value.getIdentifiers();
              EList<String> _names_1 = _identifiers_1.getNames();
              for (final String valName : _names_1) {
                {
                  parameter_type _type = value.getType();
                  String _type_1 = this.getType(_type);
                  Variable parameter = new Variable(valName, _type_1, false, ElementType.PARAMETER);
                  this.<Variable>addElement(b, parameter, this.variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
                  parameters.add(parameter);
                }
              }
            }
          }
        }
      }
    }
    return parameters;
  }
  
  public Boolean addAbstraction(final block b, final abstraction_declaration decl, final abstraction_heading heading) {
    Boolean _xblockexpression = null;
    {
      String name = heading.getName();
      block _block = decl.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        PascalFactory _pascalFactory = PascalPackage.eINSTANCE.getPascalFactory();
        block _createblock = _pascalFactory.createblock();
        decl.setBlock(_createblock);
      }
      block _block_1 = decl.getBlock();
      this.<Variable>clear(_block_1, ElementType.PARAMETER, this.variables);
      block _block_2 = decl.getBlock();
      HashSet<Variable> parameters = this.getParameters(_block_2, heading);
      boolean forward = decl.isForward();
      String returnType = heading.getReturnType();
      Boolean _xifexpression = null;
      boolean _notEquals = (!Objects.equal(returnType, null));
      if (_notEquals) {
        Function _function = new Function(name, false, parameters, forward, returnType);
        _xifexpression = this.<Procedure>addElement(b, _function, this.abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
      } else {
        Procedure _procedure = new Procedure(name, false, parameters, forward);
        _xifexpression = this.<Procedure>addElement(b, _procedure, this.abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void checkAbstractionRedeclaration(final block b) {
    procedure_and_function_declaration_part _abstraction = b.getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      this.<Procedure>clear(b, ElementType.FUNCTION, this.abstractions);
      this.<Procedure>clear(b, ElementType.PROCEDURE, this.abstractions);
      procedure_and_function_declaration_part abstraction = b.getAbstraction();
      EList<abstraction_declaration> _functions = abstraction.getFunctions();
      boolean _notEquals_1 = (!Objects.equal(_functions, null));
      if (_notEquals_1) {
        EList<abstraction_declaration> _functions_1 = abstraction.getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          abstraction_heading _heading = function.getHeading();
          this.addAbstraction(b, function, _heading);
        }
      }
      EList<abstraction_heading> _procedures = abstraction.getProcedures();
      boolean _notEquals_2 = (!Objects.equal(_procedures, null));
      if (_notEquals_2) {
        EList<abstraction_heading> _procedures_1 = abstraction.getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          abstraction_heading _heading_1 = procedure.getHeading();
          this.addAbstraction(b, procedure, _heading_1);
        }
      }
    }
  }
  
  public void checkConstantRedeclaration(final block b) {
    this.<Variable>clear(b, ElementType.CONSTANT, this.variables);
    constant_definition_part _constant = b.getConstant();
    boolean _notEquals = (!Objects.equal(_constant, null));
    if (_notEquals) {
      constant_definition_part _constant_1 = b.getConstant();
      EList<constant_definition> _consts = _constant_1.getConsts();
      for (final constant_definition const_ : _consts) {
        String _name = const_.getName();
        constant _const = const_.getConst();
        String _string = _const.toString();
        Variable _variable = new Variable(_name, _string, false, ElementType.CONSTANT);
        this.<Variable>addElement(b, _variable, this.variables, const_, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
      }
    }
  }
  
  public void checkVariableRedeclaration(final block b) {
    this.<Variable>clear(b, ElementType.VARIABLE, this.variables);
    variable_declaration_part _variable = b.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      variable_declaration_part _variable_1 = b.getVariable();
      EList<variable_section> _sections = _variable_1.getSections();
      for (final variable_section section : _sections) {
        variable_identifier_list _identifiers = section.getIdentifiers();
        EList<String> _names = _identifiers.getNames();
        for (final String name : _names) {
          type _type = section.getType();
          String _type_1 = this.getType(_type);
          Variable _variable_2 = new Variable(name, _type_1, false, ElementType.VARIABLE);
          this.<Variable>addElement(b, _variable_2, this.variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
        }
      }
    }
  }
  
  public Boolean checkVariable(final block b, final variable v, final boolean isAssignment) {
    boolean _xblockexpression = false;
    {
      Set<Variable> _get = this.variables.get(b);
      String _name = v.getName();
      Variable _variable = new Variable(_name);
      Variable searchVariable = this.<Variable>search(_get, _variable);
      boolean _xifexpression = false;
      boolean _equals = Objects.equal(searchVariable, null);
      if (_equals) {
        _xifexpression = this.insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
      } else {
        boolean _xblockexpression_1 = false;
        {
          this.removeError(v, ErrorType.NOT_DECLARATION);
          boolean _xifexpression_1 = false;
          if (isAssignment) {
            boolean _xifexpression_2 = false;
            boolean _equals_1 = Objects.equal(searchVariable.type, ElementType.CONSTANT);
            if (_equals_1) {
              _xifexpression_2 = this.insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
            } else {
              this.removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
            }
            _xifexpression_1 = _xifexpression_2;
          }
          _xblockexpression_1 = _xifexpression_1;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  public void checkAbstraction(final block b, final Procedure proc, final boolean functionOnly, final EObject object, final EStructuralFeature feature) {
    Set<Procedure> _get = this.abstractions.get(b);
    Procedure abstractionFound = this.searchWithTypeCoersion(_get, proc);
    boolean _equals = Objects.equal(abstractionFound, null);
    if (_equals) {
      Set<Procedure> _get_1 = this.abstractions.get(b);
      for (final Procedure p : _get_1) {
        String _lowerCase = p.name.toLowerCase();
        String _lowerCase_1 = proc.name.toLowerCase();
        boolean _equals_1 = _lowerCase.equals(_lowerCase_1);
        if (_equals_1) {
          int _size = p.parameters.size();
          int _size_1 = proc.parameters.size();
          boolean _notEquals = (_size != _size_1);
          if (_notEquals) {
            this.insertError(object, "Wrong number of arguments.", ErrorType.NOT_DECLARATION, feature);
          } else {
            this.insertError(object, "Incompatible types of arguments.", ErrorType.NOT_DECLARATION, feature);
          }
          return;
        }
      }
      this.insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature);
    } else {
      this.removeError(object, ErrorType.NOT_DECLARATION);
      boolean _and = false;
      boolean _equals_2 = Objects.equal(abstractionFound.type, ElementType.PROCEDURE);
      if (!_equals_2) {
        _and = false;
      } else {
        _and = functionOnly;
      }
      if (_and) {
        this.insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
      } else {
        this.removeError(object, ErrorType.FUNCTION_ONLY);
      }
    }
  }
  
  public void checkAbstractionCall(final block b, final function_designator function, final boolean functionOnly) {
    expression_list _expressions = function.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      expression_list _expressions_1 = function.getExpressions();
      EList<expression> _expressions_2 = _expressions_1.getExpressions();
      for (final expression e : _expressions_2) {
        this.checkExpression(b, e);
      }
    }
    Procedure _abstraction = this.getAbstraction(b, function);
    this.checkAbstraction(b, _abstraction, functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME);
  }
  
  public void checkExpression(final block b, final expression expr) {
    EList<simple_expression> _expressions = expr.getExpressions();
    for (final simple_expression s : _expressions) {
      EList<term> _terms = s.getTerms();
      for (final term t : _terms) {
        EList<factor> _factors = t.getFactors();
        for (final factor f : _factors) {
          {
            variable _variable = f.getVariable();
            boolean _notEquals = (!Objects.equal(_variable, null));
            if (_notEquals) {
              variable _variable_1 = f.getVariable();
              this.checkVariable(b, _variable_1, false);
            }
            function_designator _function = f.getFunction();
            boolean _notEquals_1 = (!Objects.equal(_function, null));
            if (_notEquals_1) {
              function_designator _function_1 = f.getFunction();
              this.checkAbstractionCall(b, _function_1, true);
            }
          }
        }
      }
    }
  }
  
  public Boolean checkConstant(final block b, final constant const_) {
    boolean _xifexpression = false;
    String _name = const_.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      boolean _xblockexpression = false;
      {
        Set<Variable> _get = this.variables.get(b);
        String _name_1 = const_.getName();
        Variable _variable = new Variable(_name_1);
        Variable searchVariable = this.<Variable>search(_get, _variable);
        boolean _xifexpression_1 = false;
        boolean _equals = Objects.equal(searchVariable, null);
        if (_equals) {
          _xifexpression_1 = this.insertError(const_, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
        } else {
          boolean _xblockexpression_1 = false;
          {
            this.removeError(const_, ErrorType.NOT_DECLARATION);
            boolean _xifexpression_2 = false;
            boolean _notEquals_1 = (!Objects.equal(searchVariable.type, ElementType.CONSTANT));
            if (_notEquals_1) {
              _xifexpression_2 = this.insertError(const_, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
            } else {
              this.removeError(const_, ErrorType.CONSTANT_ONLY);
            }
            _xblockexpression_1 = _xifexpression_2;
          }
          _xifexpression_1 = _xblockexpression_1;
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return Boolean.valueOf(_xifexpression);
  }
  
  public void checkStatement(final block b, final statement stmt) {
    simple_statement _simple = stmt.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_statement simple = stmt.getSimple();
      assignment_statement _assignment = simple.getAssignment();
      boolean _notEquals_1 = (!Objects.equal(_assignment, null));
      if (_notEquals_1) {
        assignment_statement _assignment_1 = simple.getAssignment();
        variable _variable = _assignment_1.getVariable();
        this.checkVariable(b, _variable, true);
        assignment_statement _assignment_2 = simple.getAssignment();
        variable _variable_1 = _assignment_2.getVariable();
        String variableType = this.getType(b, _variable_1);
        assignment_statement _assignment_3 = simple.getAssignment();
        expression _expression = _assignment_3.getExpression();
        String expressionType = this.getType(b, _expression);
        boolean _areTypesCompatibles = TypeInferer.areTypesCompatibles(variableType, expressionType);
        boolean _not = (!_areTypesCompatibles);
        if (_not) {
          assignment_statement _assignment_4 = simple.getAssignment();
          String _lowerCase = expressionType.toLowerCase();
          String _plus = ("Cannot convert type " + _lowerCase);
          String _plus_1 = (_plus + " to ");
          String _lowerCase_1 = variableType.toLowerCase();
          String _plus_2 = (_plus_1 + _lowerCase_1);
          String _plus_3 = (_plus_2 + ".");
          this.insertError(_assignment_4, _plus_3, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
        } else {
          assignment_statement _assignment_5 = simple.getAssignment();
          this.removeError(_assignment_5, ErrorType.TYPE_CONVERSION_ERROR);
        }
      } else {
        function_designator _function = simple.getFunction();
        boolean _notEquals_2 = (!Objects.equal(_function, null));
        if (_notEquals_2) {
          function_designator _function_1 = simple.getFunction();
          this.checkAbstractionCall(b, _function_1, false);
        }
      }
    } else {
      structured_statement _structured = stmt.getStructured();
      boolean _notEquals_3 = (!Objects.equal(_structured, null));
      if (_notEquals_3) {
        structured_statement structured = stmt.getStructured();
        compound_statement _compound = structured.getCompound();
        boolean _notEquals_4 = (!Objects.equal(_compound, null));
        if (_notEquals_4) {
          compound_statement compound = structured.getCompound();
          statement_sequence _sequence = compound.getSequence();
          this.checkStatements(b, _sequence);
        } else {
          repetitive_statement _repetitive = structured.getRepetitive();
          boolean _notEquals_5 = (!Objects.equal(_repetitive, null));
          if (_notEquals_5) {
            repetitive_statement repetitive = structured.getRepetitive();
            while_statement _whileStmt = repetitive.getWhileStmt();
            boolean _notEquals_6 = (!Objects.equal(_whileStmt, null));
            if (_notEquals_6) {
              while_statement _whileStmt_1 = repetitive.getWhileStmt();
              expression _expression_1 = _whileStmt_1.getExpression();
              this.checkExpression(b, _expression_1);
              while_statement _whileStmt_2 = repetitive.getWhileStmt();
              statement _statement = _whileStmt_2.getStatement();
              this.checkStatement(b, _statement);
            } else {
              repeat_statement _repeatStmt = repetitive.getRepeatStmt();
              boolean _notEquals_7 = (!Objects.equal(_repeatStmt, null));
              if (_notEquals_7) {
                repeat_statement _repeatStmt_1 = repetitive.getRepeatStmt();
                statement_sequence _sequence_1 = _repeatStmt_1.getSequence();
                this.checkStatements(b, _sequence_1);
                repeat_statement _repeatStmt_2 = repetitive.getRepeatStmt();
                expression _expression_2 = _repeatStmt_2.getExpression();
                this.checkExpression(b, _expression_2);
              } else {
                for_statement _forStmt = repetitive.getForStmt();
                boolean _notEquals_8 = (!Objects.equal(_forStmt, null));
                if (_notEquals_8) {
                  for_statement _forStmt_1 = repetitive.getForStmt();
                  assignment_statement _assignment_6 = _forStmt_1.getAssignment();
                  variable _variable_2 = _assignment_6.getVariable();
                  this.checkVariable(b, _variable_2, true);
                  for_statement _forStmt_2 = repetitive.getForStmt();
                  expression _expression_3 = _forStmt_2.getExpression();
                  this.checkExpression(b, _expression_3);
                  for_statement _forStmt_3 = repetitive.getForStmt();
                  statement _statement_1 = _forStmt_3.getStatement();
                  this.checkStatement(b, _statement_1);
                }
              }
            }
          } else {
            conditional_statement _conditional = structured.getConditional();
            boolean _notEquals_9 = (!Objects.equal(_conditional, null));
            if (_notEquals_9) {
              conditional_statement conditional = structured.getConditional();
              if_statement _ifStmt = conditional.getIfStmt();
              boolean _notEquals_10 = (!Objects.equal(_ifStmt, null));
              if (_notEquals_10) {
                if_statement ifStmt = conditional.getIfStmt();
                expression _expression_4 = ifStmt.getExpression();
                this.checkExpression(b, _expression_4);
                statement _ifStatement = ifStmt.getIfStatement();
                this.checkStatement(b, _ifStatement);
                statement _elseStatement = ifStmt.getElseStatement();
                boolean _notEquals_11 = (!Objects.equal(_elseStatement, null));
                if (_notEquals_11) {
                  statement _elseStatement_1 = ifStmt.getElseStatement();
                  this.checkStatement(b, _elseStatement_1);
                }
              } else {
                case_statement _caseStmt = conditional.getCaseStmt();
                boolean _notEquals_12 = (!Objects.equal(_caseStmt, null));
                if (_notEquals_12) {
                  case_statement caseStmt = conditional.getCaseStmt();
                  expression _expression_5 = caseStmt.getExpression();
                  this.checkExpression(b, _expression_5);
                  EList<case_limb> _cases = caseStmt.getCases();
                  for (final case_limb limb : _cases) {
                    {
                      statement _statement_2 = limb.getStatement();
                      this.checkStatement(b, _statement_2);
                      case_label_list _cases_1 = limb.getCases();
                      EList<constant> _constants = _cases_1.getConstants();
                      for (final constant c : _constants) {
                        this.checkConstant(b, c);
                      }
                    }
                  }
                }
              }
            } else {
              with_statement _withStmt = structured.getWithStmt();
              boolean _notEquals_13 = (!Objects.equal(_withStmt, null));
              if (_notEquals_13) {
                with_statement withStmt = structured.getWithStmt();
                EList<variable> _variables = withStmt.getVariables();
                for (final variable v : _variables) {
                  this.checkVariable(b, v, false);
                }
                statement _statement_2 = withStmt.getStatement();
                this.checkStatement(b, _statement_2);
              }
            }
          }
        }
      }
    }
  }
  
  public void checkStatements(final block b, final statement_sequence sequence) {
    EList<statement> _statements = sequence.getStatements();
    for (final statement stmt : _statements) {
      this.checkStatement(b, stmt);
    }
  }
  
  public void checkBlock(final block b) {
    statement_part _statement = b.getStatement();
    statement_sequence _sequence = _statement.getSequence();
    this.checkStatements(b, _sequence);
  }
  
  @Check
  public void runCheckes(final block b) {
    this.checkAbstractionRedeclaration(b);
    this.checkConstantRedeclaration(b);
    this.checkVariableRedeclaration(b);
    this.checkBlock(b);
  }
  
  @Check
  public void showError(final EObject obj) {
    boolean _containsKey = this.errorList.containsKey(obj);
    if (_containsKey) {
      Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(obj);
      for (final org.xtext.example.pascal.validation.Error err : _get) {
        String _message = err.getMessage();
        EStructuralFeature _feature = err.getFeature();
        this.error(_message, obj, _feature, (-1));
      }
    }
  }
}
