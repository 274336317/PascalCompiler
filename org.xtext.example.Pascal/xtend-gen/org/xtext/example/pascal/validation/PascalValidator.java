/**
 * generated by Xtext
 */
package org.xtext.example.pascal.validation;

import com.google.common.base.Objects;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.pascal.pascal.PascalPackage;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.constant_definition;
import org.xtext.example.pascal.pascal.constant_definition_part;
import org.xtext.example.pascal.pascal.function_declaration;
import org.xtext.example.pascal.pascal.function_heading;
import org.xtext.example.pascal.pascal.procedure_and_function_declaration_part;
import org.xtext.example.pascal.pascal.procedure_declaration;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_part;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.type;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.pascal.variable_declaration_part;
import org.xtext.example.pascal.pascal.variable_identifier_list;
import org.xtext.example.pascal.pascal.variable_section;
import org.xtext.example.pascal.validation.AbstractPascalValidator;
import org.xtext.example.pascal.validation.ErrorType;
import org.xtext.example.pascal.validation.Variable;
import org.xtext.example.pascal.validation.VariableType;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class PascalValidator extends AbstractPascalValidator {
  private Map<EObject, Set<org.xtext.example.pascal.validation.Error>> errorList = new HashMap<EObject, Set<org.xtext.example.pascal.validation.Error>>();
  
  private Map<EObject, Set<Variable>> variables = new HashMap<EObject, Set<Variable>>();
  
  public Variable search(final Set<Variable> variables, final Variable key) {
    for (final Variable v : variables) {
      boolean _equals = v.equals(key);
      if (_equals) {
        return v;
      }
    }
    return null;
  }
  
  public Set<Variable> clear(final block block, final VariableType varType) {
    Set<Variable> _xifexpression = null;
    boolean _containsKey = this.variables.containsKey(block);
    boolean _not = (!_containsKey);
    if (_not) {
      HashSet<Variable> _hashSet = new HashSet<Variable>();
      _xifexpression = this.variables.put(block, _hashSet);
    } else {
      Set<Variable> _xblockexpression = null;
      {
        HashSet<Variable> newSet = new HashSet<Variable>();
        Set<Variable> _get = this.variables.get(block);
        for (final Variable v : _get) {
          boolean _or = false;
          VariableType _varType = v.getVarType();
          boolean _notEquals = (!Objects.equal(_varType, varType));
          if (_notEquals) {
            _or = true;
          } else {
            boolean _isInherited = v.isInherited();
            _or = _isInherited;
          }
          if (_or) {
            newSet.add(v);
          }
        }
        _xblockexpression = this.variables.put(block, newSet);
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  public boolean insertError(final EObject object, final String message, final ErrorType type, final EStructuralFeature feature) {
    boolean _xblockexpression = false;
    {
      boolean _containsKey = this.errorList.containsKey(object);
      boolean _not = (!_containsKey);
      if (_not) {
        HashSet<org.xtext.example.pascal.validation.Error> _hashSet = new HashSet<org.xtext.example.pascal.validation.Error>();
        this.errorList.put(object, _hashSet);
      }
      Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(object);
      org.xtext.example.pascal.validation.Error _error = new org.xtext.example.pascal.validation.Error(message, type, feature);
      _xblockexpression = _get.add(_error);
    }
    return _xblockexpression;
  }
  
  public boolean removeError(final EObject object, final ErrorType type) {
    boolean _xblockexpression = false;
    {
      boolean _containsKey = this.errorList.containsKey(object);
      boolean _not = (!_containsKey);
      if (_not) {
        HashSet<org.xtext.example.pascal.validation.Error> _hashSet = new HashSet<org.xtext.example.pascal.validation.Error>();
        this.errorList.put(object, _hashSet);
      }
      Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(object);
      org.xtext.example.pascal.validation.Error _error = new org.xtext.example.pascal.validation.Error(type);
      _xblockexpression = _get.remove(_error);
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkConstantRedeclaration(final block block) {
    this.clear(block, VariableType.CONSTANT);
    constant_definition_part _constant = block.getConstant();
    boolean _notEquals = (!Objects.equal(_constant, null));
    if (_notEquals) {
      constant_definition_part _constant_1 = block.getConstant();
      EList<constant_definition> _consts = _constant_1.getConsts();
      for (final constant_definition const_ : _consts) {
        {
          String _name = const_.getName();
          Variable tempConst = new Variable(_name, null, false, VariableType.CONSTANT);
          Set<Variable> _get = this.variables.get(block);
          Variable searchConst = this.search(_get, tempConst);
          boolean _and = false;
          boolean _notEquals_1 = (!Objects.equal(searchConst, null));
          if (!_notEquals_1) {
            _and = false;
          } else {
            boolean _isInherited = searchConst.isInherited();
            boolean _not = (!_isInherited);
            _and = _not;
          }
          if (_and) {
            VariableType _varType = searchConst.getVarType();
            boolean _equals = Objects.equal(_varType, VariableType.PARAMETER);
            if (_equals) {
              this.insertError(const_, "Identifier is already being used by a parameter.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
            } else {
              VariableType _varType_1 = searchConst.getVarType();
              boolean _equals_1 = Objects.equal(_varType_1, VariableType.VARIABLE);
              if (_equals_1) {
                this.insertError(const_, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
              } else {
                this.insertError(const_, "Constant cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
              }
            }
          } else {
            this.removeError(const_, ErrorType.REDECLARATION);
            Set<Variable> _get_1 = this.variables.get(block);
            _get_1.remove(searchConst);
            Set<Variable> _get_2 = this.variables.get(block);
            _get_2.add(tempConst);
            procedure_and_function_declaration_part _abstraction = block.getAbstraction();
            boolean _notEquals_2 = (!Objects.equal(_abstraction, null));
            if (_notEquals_2) {
              procedure_and_function_declaration_part _abstraction_1 = block.getAbstraction();
              EList<procedure_declaration> _procedures = _abstraction_1.getProcedures();
              boolean _notEquals_3 = (!Objects.equal(_procedures, null));
              if (_notEquals_3) {
                procedure_and_function_declaration_part _abstraction_2 = block.getAbstraction();
                EList<procedure_declaration> _procedures_1 = _abstraction_2.getProcedures();
                for (final procedure_declaration declaration : _procedures_1) {
                  org.xtext.example.pascal.pascal.block _block = declaration.getBlock();
                  boolean _notEquals_4 = (!Objects.equal(_block, null));
                  if (_notEquals_4) {
                    org.xtext.example.pascal.pascal.block subblock = declaration.getBlock();
                    boolean _containsKey = this.variables.containsKey(subblock);
                    boolean _not_1 = (!_containsKey);
                    if (_not_1) {
                      HashSet<Variable> _hashSet = new HashSet<Variable>();
                      this.variables.put(subblock, _hashSet);
                    }
                    Set<Variable> _get_3 = this.variables.get(subblock);
                    String _name_1 = const_.getName();
                    Variable _variable = new Variable(_name_1, null, true, VariableType.CONSTANT);
                    _get_3.add(_variable);
                  }
                }
              }
              procedure_and_function_declaration_part _abstraction_3 = block.getAbstraction();
              EList<function_declaration> _functions = _abstraction_3.getFunctions();
              boolean _notEquals_5 = (!Objects.equal(_functions, null));
              if (_notEquals_5) {
                procedure_and_function_declaration_part _abstraction_4 = block.getAbstraction();
                EList<function_declaration> _functions_1 = _abstraction_4.getFunctions();
                for (final function_declaration declaration_1 : _functions_1) {
                  org.xtext.example.pascal.pascal.block _block_1 = declaration_1.getBlock();
                  boolean _notEquals_6 = (!Objects.equal(_block_1, null));
                  if (_notEquals_6) {
                    org.xtext.example.pascal.pascal.block subblock_1 = declaration_1.getBlock();
                    boolean _containsKey_1 = this.variables.containsKey(subblock_1);
                    boolean _not_2 = (!_containsKey_1);
                    if (_not_2) {
                      HashSet<Variable> _hashSet_1 = new HashSet<Variable>();
                      this.variables.put(subblock_1, _hashSet_1);
                    }
                    Set<Variable> _get_4 = this.variables.get(subblock_1);
                    String _name_2 = const_.getName();
                    Variable _variable_1 = new Variable(_name_2, null, true, VariableType.CONSTANT);
                    _get_4.add(_variable_1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkVariableRedeclaration(final block block) {
    this.clear(block, VariableType.VARIABLE);
    variable_declaration_part _variable = block.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      variable_declaration_part _variable_1 = block.getVariable();
      EList<variable_section> _sections = _variable_1.getSections();
      for (final variable_section section : _sections) {
        variable_identifier_list _identifiers = section.getIdentifiers();
        EList<String> _names = _identifiers.getNames();
        for (final String name : _names) {
          {
            type _type = section.getType();
            Variable tempVariable = new Variable(name, _type, false, VariableType.VARIABLE);
            Set<Variable> _get = this.variables.get(block);
            Variable searchVariable = this.search(_get, tempVariable);
            boolean _and = false;
            boolean _notEquals_1 = (!Objects.equal(searchVariable, null));
            if (!_notEquals_1) {
              _and = false;
            } else {
              boolean _isInherited = searchVariable.isInherited();
              boolean _not = (!_isInherited);
              _and = _not;
            }
            if (_and) {
              VariableType _varType = searchVariable.getVarType();
              boolean _equals = Objects.equal(_varType, VariableType.PARAMETER);
              if (_equals) {
                this.insertError(section, "Identifier is already being used by a parameter.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
              } else {
                VariableType _varType_1 = searchVariable.getVarType();
                boolean _equals_1 = Objects.equal(_varType_1, VariableType.CONSTANT);
                if (_equals_1) {
                  this.insertError(section, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
                } else {
                  this.insertError(section, "Variable cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
                }
              }
            } else {
              this.removeError(section, ErrorType.REDECLARATION);
              Set<Variable> _get_1 = this.variables.get(block);
              _get_1.remove(searchVariable);
              Set<Variable> _get_2 = this.variables.get(block);
              _get_2.add(tempVariable);
              procedure_and_function_declaration_part _abstraction = block.getAbstraction();
              boolean _notEquals_2 = (!Objects.equal(_abstraction, null));
              if (_notEquals_2) {
                procedure_and_function_declaration_part _abstraction_1 = block.getAbstraction();
                EList<procedure_declaration> _procedures = _abstraction_1.getProcedures();
                boolean _notEquals_3 = (!Objects.equal(_procedures, null));
                if (_notEquals_3) {
                  procedure_and_function_declaration_part _abstraction_2 = block.getAbstraction();
                  EList<procedure_declaration> _procedures_1 = _abstraction_2.getProcedures();
                  for (final procedure_declaration declaration : _procedures_1) {
                    org.xtext.example.pascal.pascal.block _block = declaration.getBlock();
                    boolean _notEquals_4 = (!Objects.equal(_block, null));
                    if (_notEquals_4) {
                      org.xtext.example.pascal.pascal.block subblock = declaration.getBlock();
                      boolean _containsKey = this.variables.containsKey(subblock);
                      boolean _not_1 = (!_containsKey);
                      if (_not_1) {
                        HashSet<Variable> _hashSet = new HashSet<Variable>();
                        this.variables.put(subblock, _hashSet);
                      }
                      Set<Variable> _get_3 = this.variables.get(subblock);
                      type _type_1 = section.getType();
                      Variable _variable_2 = new Variable(name, _type_1, true, VariableType.VARIABLE);
                      _get_3.add(_variable_2);
                    }
                  }
                }
                procedure_and_function_declaration_part _abstraction_3 = block.getAbstraction();
                EList<function_declaration> _functions = _abstraction_3.getFunctions();
                boolean _notEquals_5 = (!Objects.equal(_functions, null));
                if (_notEquals_5) {
                  procedure_and_function_declaration_part _abstraction_4 = block.getAbstraction();
                  EList<function_declaration> _functions_1 = _abstraction_4.getFunctions();
                  for (final function_declaration declaration_1 : _functions_1) {
                    org.xtext.example.pascal.pascal.block _block_1 = declaration_1.getBlock();
                    boolean _notEquals_6 = (!Objects.equal(_block_1, null));
                    if (_notEquals_6) {
                      org.xtext.example.pascal.pascal.block subblock_1 = declaration_1.getBlock();
                      boolean _containsKey_1 = this.variables.containsKey(subblock_1);
                      boolean _not_2 = (!_containsKey_1);
                      if (_not_2) {
                        HashSet<Variable> _hashSet_1 = new HashSet<Variable>();
                        this.variables.put(subblock_1, _hashSet_1);
                      }
                      Set<Variable> _get_4 = this.variables.get(subblock_1);
                      type _type_2 = section.getType();
                      Variable _variable_3 = new Variable(name, _type_2, true, VariableType.VARIABLE);
                      _get_4.add(_variable_3);
                      Set<Variable> _get_5 = this.variables.get(subblock_1);
                      function_heading _heading = declaration_1.getHeading();
                      String _name = _heading.getName();
                      Variable _variable_4 = new Variable(_name, null, true, VariableType.VARIABLE);
                      _get_5.add(_variable_4);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkVariableAssignment(final block block) {
    statement_part _statement = block.getStatement();
    statement_sequence _sequence = _statement.getSequence();
    EList<statement> _statements = _sequence.getStatements();
    for (final statement stmt : _statements) {
      simple_statement _simple = stmt.getSimple();
      boolean _notEquals = (!Objects.equal(_simple, null));
      if (_notEquals) {
        simple_statement simple = stmt.getSimple();
        assignment_statement _assignment = simple.getAssignment();
        boolean _notEquals_1 = (!Objects.equal(_assignment, null));
        if (_notEquals_1) {
          assignment_statement assignment = simple.getAssignment();
          variable variable = assignment.getVariable();
          Set<Variable> _get = this.variables.get(block);
          String _name = variable.getName();
          Variable _variable = new Variable(_name);
          Variable searchVariable = this.search(_get, _variable);
          boolean _equals = Objects.equal(searchVariable, null);
          if (_equals) {
            this.insertError(variable, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
          } else {
            this.removeError(variable, ErrorType.NOT_DECLARATION);
            VariableType _varType = searchVariable.getVarType();
            boolean _equals_1 = Objects.equal(_varType, VariableType.CONSTANT);
            if (_equals_1) {
              this.insertError(variable, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
            } else {
              this.removeError(variable, ErrorType.CONSTANT_ASSIGNMENT);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void showError(final EObject obj) {
    boolean _containsKey = this.errorList.containsKey(obj);
    if (_containsKey) {
      Set<org.xtext.example.pascal.validation.Error> _get = this.errorList.get(obj);
      for (final org.xtext.example.pascal.validation.Error err : _get) {
        String _message = err.getMessage();
        EStructuralFeature _feature = err.getFeature();
        this.error(_message, _feature);
      }
    }
  }
}
