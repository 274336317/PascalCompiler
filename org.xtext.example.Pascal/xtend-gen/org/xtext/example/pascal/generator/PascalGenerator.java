/**
 * generated by Xtext
 */
package org.xtext.example.pascal.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.pascal.pascal.abstraction_declaration;
import org.xtext.example.pascal.pascal.abstraction_heading;
import org.xtext.example.pascal.pascal.any_number;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.case_label_list;
import org.xtext.example.pascal.pascal.case_limb;
import org.xtext.example.pascal.pascal.case_statement;
import org.xtext.example.pascal.pascal.compound_statement;
import org.xtext.example.pascal.pascal.conditional_statement;
import org.xtext.example.pascal.pascal.constant;
import org.xtext.example.pascal.pascal.expression;
import org.xtext.example.pascal.pascal.expression_list;
import org.xtext.example.pascal.pascal.factor;
import org.xtext.example.pascal.pascal.function_designator;
import org.xtext.example.pascal.pascal.if_statement;
import org.xtext.example.pascal.pascal.number;
import org.xtext.example.pascal.pascal.procedure_and_function_declaration_part;
import org.xtext.example.pascal.pascal.program;
import org.xtext.example.pascal.pascal.program_heading_block;
import org.xtext.example.pascal.pascal.repetitive_statement;
import org.xtext.example.pascal.pascal.simple_expression;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_part;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.structured_statement;
import org.xtext.example.pascal.pascal.term;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.validation.ElementType;
import org.xtext.example.pascal.validation.Function;
import org.xtext.example.pascal.validation.PascalValidator;
import org.xtext.example.pascal.validation.Procedure;
import org.xtext.example.pascal.validation.Type;
import org.xtext.example.pascal.validation.TypeInferer;
import org.xtext.example.pascal.validation.Variable;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class PascalGenerator implements IGenerator {
  private HashMap<String, String> stringTable = new HashMap<String, String>();
  
  private int labelCount;
  
  private int conditionalLabelCount;
  
  private int caseLabelCount;
  
  private int caseGlobalLabelCount;
  
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<program> _filter = Iterables.<program>filter(_iterable, program.class);
    for (final program e : _filter) {
      {
        this.labelCount = 0;
        this.conditionalLabelCount = 0;
        this.caseLabelCount = 0;
        this.caseGlobalLabelCount = 0;
        this.stringTable.clear();
        program_heading_block _heading = e.getHeading();
        String _name = _heading.getName();
        String _plus = (_name + ".asm");
        CharSequence _compile = this.compile(e);
        fsa.generateFile(_plus, _compile);
      }
    }
  }
  
  public void createStringTable(final program e) {
    TreeIterator<EObject> _eAllContents = e.eAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_eAllContents);
    Iterable<factor> _filter = Iterables.<factor>filter(_iterable, factor.class);
    for (final factor s : _filter) {
      String _string = s.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        String _string_1 = s.getString();
        boolean _containsKey = this.stringTable.containsKey(_string_1);
        boolean _not = (!_containsKey);
        if (_not) {
          String _string_2 = s.getString();
          int _size = this.stringTable.size();
          String _plus = ("__STRING_" + Integer.valueOf(_size));
          this.stringTable.put(_string_2, _plus);
        }
      }
    }
    TreeIterator<EObject> _eAllContents_1 = e.eAllContents();
    Iterable<EObject> _iterable_1 = IteratorExtensions.<EObject>toIterable(_eAllContents_1);
    Iterable<constant> _filter_1 = Iterables.<constant>filter(_iterable_1, constant.class);
    for (final constant const_ : _filter_1) {
      String _string_3 = const_.getString();
      boolean _notEquals_1 = (!Objects.equal(_string_3, null));
      if (_notEquals_1) {
        String _string_4 = const_.getString();
        boolean _containsKey_1 = this.stringTable.containsKey(_string_4);
        boolean _not_1 = (!_containsKey_1);
        if (_not_1) {
          String _string_5 = const_.getString();
          int _size_1 = this.stringTable.size();
          String _plus_1 = ("__STRING_" + Integer.valueOf(_size_1));
          this.stringTable.put(_string_5, _plus_1);
        }
      }
    }
  }
  
  public String getName(final block b) {
    String _string = b.toString();
    String lastName = _string.replaceAll("org.xtext.example.pascal.pascal.impl.blockImpl@", "");
    return lastName;
  }
  
  public Map<block, Set<Variable>> getVariables(final program e) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("variables");
    Map<block, Set<Variable>> map = ((Map<block, Set<Variable>>) _get);
    return map;
  }
  
  public Set<Variable> getVariables(final program e, final block b) {
    Map<block, Set<Variable>> _variables = this.getVariables(e);
    return _variables.get(b);
  }
  
  public Map<block, Set<Procedure>> getProcedures(final program e) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("abstractions");
    Map<block, Set<Procedure>> map = ((Map<block, Set<Procedure>>) _get);
    return map;
  }
  
  public Set<Procedure> getProcedures(final program e, final block b) {
    Map<block, Set<Procedure>> _procedures = this.getProcedures(e);
    return _procedures.get(b);
  }
  
  public Object getValue(final Variable v) {
    Object _value = v.getValue();
    if ((_value instanceof String)) {
      Object _value_1 = v.getValue();
      String _string = _value_1.toString();
      String _replaceAll = _string.replaceAll("\'", "\"");
      String _plus = ("\'" + _replaceAll);
      return (_plus + "\'");
    } else {
      Object _value_2 = v.getValue();
      if ((_value_2 instanceof Boolean)) {
        Object _value_3 = v.getValue();
        boolean _equals = _value_3.equals(Boolean.valueOf(true));
        if (_equals) {
          return Integer.valueOf(1);
        } else {
          return Integer.valueOf(0);
        }
      }
    }
    return v.getValue();
  }
  
  public Object getValue(final program e, final block b, final constant const_) {
    Set<Variable> variables = this.getVariables(e, b);
    Object value = PascalValidator.getValue(const_, variables);
    if ((value instanceof String)) {
      String _name = const_.getName();
      boolean _equals = Objects.equal(_name, null);
      if (_equals) {
        boolean _containsKey = this.stringTable.containsKey(value);
        if (_containsKey) {
          return this.stringTable.get(value);
        }
      } else {
        return const_.getName();
      }
    } else {
      if ((value instanceof Boolean)) {
        if ((((Boolean) value).booleanValue() == true)) {
          return Integer.valueOf(1);
        }
        return Integer.valueOf(0);
      }
    }
    return value;
  }
  
  public List<Variable> getArgumentTypes(final program e, final block b, final expression_list expList) {
    List<Variable> list = new ArrayList<Variable>();
    boolean _or = false;
    boolean _equals = Objects.equal(expList, null);
    if (_equals) {
      _or = true;
    } else {
      EList<expression> _expressions = expList.getExpressions();
      boolean _equals_1 = Objects.equal(_expressions, null);
      _or = _equals_1;
    }
    if (_or) {
      return list;
    }
    int count = 0;
    EList<expression> _expressions_1 = expList.getExpressions();
    for (final expression exp : _expressions_1) {
      int _plusPlus = count++;
      String _plus = ("arg_" + Integer.valueOf(_plusPlus));
      Type _type = this.getType(e, exp);
      Variable _variable = new Variable(_plus, _type, false, null, ElementType.PARAMETER);
      list.add(_variable);
    }
    return list;
  }
  
  public Type getType(final program e, final expression expr) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("calculatedTypes");
    Map<EObject, Type> map = ((Map<EObject, Type>) _get);
    return map.get(expr);
  }
  
  public CharSequence compile(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Program ");
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    _builder.append(_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("global _main");
    _builder.newLine();
    _builder.newLine();
    _builder.append("extern _printf");
    _builder.newLine();
    _builder.append("extern _scanf ");
    _builder.newLine();
    _builder.newLine();
    _builder.append("; Loading constants and strings");
    _builder.newLine();
    _builder.append("section .data");
    _builder.newLine();
    _builder.append("\t");
    this.createStringTable(e);
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _compileStrings = this.compileStrings(e);
    _builder.append(_compileStrings, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    block _block = e.getBlock();
    CharSequence _compileAllConstants = this.compileAllConstants(e, _block);
    _builder.append(_compileAllConstants, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("; Loading variables");
    _builder.newLine();
    _builder.append("section .bss");
    _builder.newLine();
    _builder.append("\t");
    block _block_1 = e.getBlock();
    CharSequence _compileAllVariables = this.compileAllVariables(e, _block_1);
    _builder.append(_compileAllVariables, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("; Code");
    _builder.newLine();
    _builder.append("section .text");
    _builder.newLine();
    CharSequence _printString = this.printString(e);
    _builder.append(_printString, "");
    _builder.newLineIfNotEmpty();
    CharSequence _printInteger = this.printInteger(e);
    _builder.append(_printInteger, "");
    _builder.newLineIfNotEmpty();
    CharSequence _printBoolean = this.printBoolean(e);
    _builder.append(_printBoolean, "");
    _builder.newLineIfNotEmpty();
    block _block_2 = e.getBlock();
    CharSequence _compileAllProcedures = this.compileAllProcedures(e, _block_2);
    _builder.append(_compileAllProcedures, "");
    _builder.newLineIfNotEmpty();
    _builder.append("_main:");
    _builder.newLine();
    block _block_3 = e.getBlock();
    block _block_4 = e.getBlock();
    statement_part _statement = _block_4.getStatement();
    statement_sequence _sequence = _statement.getSequence();
    CharSequence _compileSequence = this.compileSequence(e, _block_3, _sequence);
    _builder.append(_compileSequence, "");
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.append("ret\t; Exit program");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compileAllProcedures(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    Set<Procedure> _procedures = this.getProcedures(e, b);
    CharSequence _compileProcedures = this.compileProcedures(e, b, _procedures);
    _builder.append(_compileProcedures, "");
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          procedure_and_function_declaration_part _abstraction_1 = b.getAbstraction();
          EList<abstraction_heading> _procedures_1 = _abstraction_1.getProcedures();
          for(final abstraction_heading p : _procedures_1) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                block _block_1 = p.getBlock();
                CharSequence _compileAllProcedures = this.compileAllProcedures(e, _block_1);
                _builder.append(_compileAllProcedures, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          procedure_and_function_declaration_part _abstraction_2 = b.getAbstraction();
          EList<abstraction_declaration> _functions = _abstraction_2.getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_2 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_2, null));
              if (_notEquals_2) {
                block _block_3 = p_1.getBlock();
                CharSequence _compileAllProcedures_1 = this.compileAllProcedures(e, _block_3);
                _builder.append(_compileAllProcedures_1, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence compileAllVariables(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    Set<Variable> _variables = this.getVariables(e, b);
    CharSequence _compileVariables = this.compileVariables(e, b, _variables);
    _builder.append(_compileVariables, "");
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          procedure_and_function_declaration_part _abstraction_1 = b.getAbstraction();
          EList<abstraction_heading> _procedures = _abstraction_1.getProcedures();
          for(final abstraction_heading p : _procedures) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                block _block_1 = p.getBlock();
                CharSequence _compileAllVariables = this.compileAllVariables(e, _block_1);
                _builder.append(_compileAllVariables, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          procedure_and_function_declaration_part _abstraction_2 = b.getAbstraction();
          EList<abstraction_declaration> _functions = _abstraction_2.getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_2 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_2, null));
              if (_notEquals_2) {
                block _block_3 = p_1.getBlock();
                CharSequence _compileAllVariables_1 = this.compileAllVariables(e, _block_3);
                _builder.append(_compileAllVariables_1, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence compileAllConstants(final program e, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    Set<Variable> _variables = this.getVariables(e, b);
    CharSequence _compileConstants = this.compileConstants(e, b, _variables);
    _builder.append(_compileConstants, "");
    _builder.newLineIfNotEmpty();
    {
      procedure_and_function_declaration_part _abstraction = b.getAbstraction();
      boolean _notEquals = (!Objects.equal(_abstraction, null));
      if (_notEquals) {
        {
          procedure_and_function_declaration_part _abstraction_1 = b.getAbstraction();
          EList<abstraction_heading> _procedures = _abstraction_1.getProcedures();
          for(final abstraction_heading p : _procedures) {
            {
              block _block = p.getBlock();
              boolean _notEquals_1 = (!Objects.equal(_block, null));
              if (_notEquals_1) {
                block _block_1 = p.getBlock();
                CharSequence _compileAllConstants = this.compileAllConstants(e, _block_1);
                _builder.append(_compileAllConstants, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        {
          procedure_and_function_declaration_part _abstraction_2 = b.getAbstraction();
          EList<abstraction_declaration> _functions = _abstraction_2.getFunctions();
          for(final abstraction_declaration p_1 : _functions) {
            {
              block _block_2 = p_1.getBlock();
              boolean _notEquals_2 = (!Objects.equal(_block_2, null));
              if (_notEquals_2) {
                block _block_3 = p_1.getBlock();
                CharSequence _compileAllConstants_1 = this.compileAllConstants(e, _block_3);
                _builder.append(_compileAllConstants_1, "");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence printString(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print string");
    _builder.newLine();
    _builder.append("_print_string:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], dword eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop eax ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printInteger(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print integer");
    _builder.newLine();
    _builder.append("_print_integer:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("lea eax, [__PRINTF_I]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return ");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printBoolean(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print boolean");
    _builder.newLine();
    _builder.append("_print_boolean:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("jnz .print_boolean_true");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _print = this.print(e, "__BOOLEAN_FALSE");
    _builder.append(_print, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.append(".print_boolean_true:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _print_1 = this.print(e, "__BOOLEAN_TRUE");
    _builder.append(_print_1, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compileConstant(final program e, final block b, final Variable v) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _and = false;
      boolean _and_1 = false;
      ElementType _type = v.getType();
      boolean _equals = Objects.equal(_type, ElementType.CONSTANT);
      if (!_equals) {
        _and_1 = false;
      } else {
        boolean _isInherited = v.isInherited();
        boolean _not = (!_isInherited);
        _and_1 = _not;
      }
      if (!_and_1) {
        _and = false;
      } else {
        Type _varType = v.getVarType();
        String _realType = _varType.getRealType();
        String _lowerCase = _realType.toLowerCase();
        boolean _equals_1 = _lowerCase.equals("array of char");
        boolean _not_1 = (!_equals_1);
        _and = _not_1;
      }
      if (_and) {
        String _name = v.getName();
        _builder.append(_name, "");
        _builder.append("_");
        String _name_1 = this.getName(b);
        _builder.append(_name_1, "");
        _builder.append(" equ ");
        Object _value = this.getValue(v);
        _builder.append(_value, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileString(final program e, final String name, final String value) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(value, "");
    _builder.append(" db \'");
    String _replaceAll = name.replaceAll("\'", "");
    _builder.append(_replaceAll, "");
    _builder.append("\', 0");
    _builder.newLineIfNotEmpty();
    _builder.append(value, "");
    _builder.append("_SIZE equ $-");
    _builder.append(value, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compileVariable(final program e, final block b, final Variable v) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _and = false;
      boolean _or = false;
      boolean _or_1 = false;
      ElementType _type = v.getType();
      boolean _equals = Objects.equal(_type, ElementType.VARIABLE);
      if (_equals) {
        _or_1 = true;
      } else {
        ElementType _type_1 = v.getType();
        boolean _equals_1 = Objects.equal(_type_1, ElementType.PARAMETER);
        _or_1 = _equals_1;
      }
      if (_or_1) {
        _or = true;
      } else {
        ElementType _type_2 = v.getType();
        boolean _equals_2 = Objects.equal(_type_2, ElementType.FUNCTION_RETURN);
        _or = _equals_2;
      }
      if (!_or) {
        _and = false;
      } else {
        boolean _isInherited = v.isInherited();
        boolean _not = (!_isInherited);
        _and = _not;
      }
      if (_and) {
        {
          Type _varType = v.getVarType();
          String _realType = _varType.getRealType();
          String _lowerCase = _realType.toLowerCase();
          boolean _equals_3 = _lowerCase.equals("array of char");
          boolean _not_1 = (!_equals_3);
          if (_not_1) {
            {
              ElementType _type_3 = v.getType();
              boolean _equals_4 = Objects.equal(_type_3, ElementType.FUNCTION_RETURN);
              if (_equals_4) {
                String _extendedName = v.getExtendedName();
                _builder.append(_extendedName, "");
                _builder.append("_");
                String _name = this.getName(b);
                _builder.append(_name, "");
                _builder.append(" RESB 4");
                _builder.newLineIfNotEmpty();
              } else {
                String _name_1 = v.getName();
                _builder.append(_name_1, "");
                _builder.append("_");
                String _name_2 = this.getName(b);
                _builder.append(_name_2, "");
                _builder.append(" RESB 4");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence compileStrings(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("__NEW_LINE db 10, 0");
    _builder.newLine();
    _builder.append("__NEW_LINE_SIZE equ $-__NEW_LINE");
    _builder.newLine();
    _builder.append("__PRINTF_S db \'%s\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_I db \'%d\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_F db \'%f\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE db \'true\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE_SIZE equ $-__BOOLEAN_TRUE");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE db \'false\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE_SIZE equ $-__BOOLEAN_FALSE");
    _builder.newLine();
    {
      Set<String> _keySet = this.stringTable.keySet();
      for(final String s : _keySet) {
        String _get = this.stringTable.get(s);
        CharSequence _compileString = this.compileString(e, s, _get);
        _builder.append(_compileString, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileConstants(final program e, final block b, final Set<Variable> variables) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Variable variable : variables) {
        CharSequence _compileConstant = this.compileConstant(e, b, variable);
        _builder.append(_compileConstant, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileVariables(final program e, final block b, final Set<Variable> variables) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Variable variable : variables) {
        CharSequence _compileVariable = this.compileVariable(e, b, variable);
        _builder.append(_compileVariable, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileProcedures(final program e, final block b, final Set<Procedure> procedures) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final Procedure procedure : procedures) {
        CharSequence _compileProcedure = this.compileProcedure(e, b, procedure);
        _builder.append(_compileProcedure, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileProcedure(final program e, final block b, final Procedure procedure) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _and = false;
      boolean _isForward = procedure.isForward();
      boolean _not = (!_isForward);
      if (!_not) {
        _and = false;
      } else {
        boolean _isInherited = procedure.isInherited();
        boolean _not_1 = (!_isInherited);
        _and = _not_1;
      }
      if (_and) {
        _builder.append("; Procedure ");
        String _name = procedure.getName();
        _builder.append(_name, "");
        List<Variable> _parameters = procedure.getParameters();
        _builder.append(_parameters, "");
        _builder.newLineIfNotEmpty();
        _builder.append("_");
        String _extendedName = procedure.getExtendedName();
        _builder.append(_extendedName, "");
        _builder.append("_");
        String _name_1 = this.getName(b);
        _builder.append(_name_1, "");
        _builder.append(":");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        abstraction_declaration _declaration = procedure.getDeclaration();
        block _block = _declaration.getBlock();
        abstraction_declaration _declaration_1 = procedure.getDeclaration();
        block _block_1 = _declaration_1.getBlock();
        statement_part _statement = _block_1.getStatement();
        statement_sequence _sequence = _statement.getSequence();
        CharSequence _compileSequence = this.compileSequence(e, _block, _sequence);
        _builder.append(_compileSequence, "\t");
        _builder.newLineIfNotEmpty();
        {
          if ((procedure instanceof Function)) {
            _builder.append("\t");
            _builder.append("mov eax, [");
            String _extendedName_1 = ((Function)procedure).getExtendedName();
            _builder.append(_extendedName_1, "\t");
            _builder.append("_");
            abstraction_declaration _declaration_2 = ((Function)procedure).getDeclaration();
            block _block_2 = _declaration_2.getBlock();
            String _name_2 = this.getName(_block_2);
            _builder.append(_name_2, "\t");
            _builder.append("]");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("ret ;return");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence computeFunction(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    String name = function.getName();
    _builder.newLineIfNotEmpty();
    expression_list _expressions = function.getExpressions();
    List<Variable> arguments = this.getArgumentTypes(e, b, _expressions);
    _builder.newLineIfNotEmpty();
    Procedure functionToSearch = new Procedure(name, arguments);
    _builder.newLineIfNotEmpty();
    Set<Procedure> _procedures = this.getProcedures(e, b);
    Procedure functionFound = PascalValidator.searchWithTypeCoersion(_procedures, functionToSearch);
    _builder.newLineIfNotEmpty();
    {
      List<Variable> _parameters = functionFound.getParameters();
      for(final Variable arg : _parameters) {
        _builder.append("mov edx, ");
        String _name = arg.getName();
        _builder.append(_name, "");
        _builder.append("_");
        abstraction_declaration _declaration = functionFound.getDeclaration();
        block _block = _declaration.getBlock();
        String _name_1 = this.getName(_block);
        _builder.append(_name_1, "");
        _builder.newLineIfNotEmpty();
        _builder.append("push edx");
        _builder.newLine();
      }
    }
    {
      boolean _and = false;
      expression_list _expressions_1 = function.getExpressions();
      boolean _notEquals = (!Objects.equal(_expressions_1, null));
      if (!_notEquals) {
        _and = false;
      } else {
        expression_list _expressions_2 = function.getExpressions();
        EList<expression> _expressions_3 = _expressions_2.getExpressions();
        boolean _notEquals_1 = (!Objects.equal(_expressions_3, null));
        _and = _notEquals_1;
      }
      if (_and) {
        expression_list _expressions_4 = function.getExpressions();
        EList<expression> exps = _expressions_4.getExpressions();
        _builder.newLineIfNotEmpty();
        {
          int _size = exps.size();
          int _minus = (_size - 1);
          IntegerRange _upTo = new IntegerRange(0, _minus);
          for(final Integer i : _upTo) {
            expression _get = exps.get((i).intValue());
            CharSequence _computeExpression = this.computeExpression(e, b, _get);
            _builder.append(_computeExpression, "");
            _builder.newLineIfNotEmpty();
            _builder.append("mov [");
            List<Variable> _parameters_1 = functionFound.getParameters();
            Variable _get_1 = _parameters_1.get((i).intValue());
            String _name_2 = _get_1.getName();
            _builder.append(_name_2, "");
            _builder.append("_");
            abstraction_declaration _declaration_1 = functionFound.getDeclaration();
            block _block_1 = _declaration_1.getBlock();
            String _name_3 = this.getName(_block_1);
            _builder.append(_name_3, "");
            _builder.append("], eax");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("call _");
    String _extendedName = functionFound.getExtendedName();
    _builder.append(_extendedName, "");
    _builder.append("_");
    block _containingBlock = functionFound.getContainingBlock();
    String _name_4 = this.getName(_containingBlock);
    _builder.append(_name_4, "");
    _builder.newLineIfNotEmpty();
    {
      List<Variable> _parameters_2 = functionFound.getParameters();
      for(final Variable arg_1 : _parameters_2) {
        _builder.append("pop edx");
        _builder.newLine();
        _builder.append("mov [");
        String _name_5 = arg_1.getName();
        _builder.append(_name_5, "");
        _builder.append("_");
        abstraction_declaration _declaration_2 = functionFound.getDeclaration();
        block _block_2 = _declaration_2.getBlock();
        String _name_6 = this.getName(_block_2);
        _builder.append(_name_6, "");
        _builder.append("], edx");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence computeFactor(final program e, final block b, final factor f) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _string = f.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        _builder.append("lea eax, [");
        String _string_1 = f.getString();
        String _get = this.stringTable.get(_string_1);
        _builder.append(_get, "");
        _builder.append("]");
        _builder.newLineIfNotEmpty();
        _builder.append("mov ebx, ");
        String _string_2 = f.getString();
        String _get_1 = this.stringTable.get(_string_2);
        _builder.append(_get_1, "");
        _builder.append("_SIZE");
        _builder.newLineIfNotEmpty();
      } else {
        number _number = f.getNumber();
        boolean _notEquals_1 = (!Objects.equal(_number, null));
        if (_notEquals_1) {
          {
            number _number_1 = f.getNumber();
            any_number _number_2 = _number_1.getNumber();
            String _integer = _number_2.getInteger();
            boolean _notEquals_2 = (!Objects.equal(_integer, null));
            if (_notEquals_2) {
              _builder.append("mov eax, ");
              number _number_3 = f.getNumber();
              any_number _number_4 = _number_3.getNumber();
              String _integer_1 = _number_4.getInteger();
              _builder.append(_integer_1, "");
              _builder.newLineIfNotEmpty();
            } else {
            }
          }
        } else {
          String _boolean = f.getBoolean();
          boolean _notEquals_3 = (!Objects.equal(_boolean, null));
          if (_notEquals_3) {
            {
              String _boolean_1 = f.getBoolean();
              String _lowerCase = _boolean_1.toLowerCase();
              boolean _equals = _lowerCase.equals("true");
              if (_equals) {
                _builder.append("mov eax, 1");
                _builder.newLine();
              } else {
                _builder.append("mov eax, 0");
                _builder.newLine();
              }
            }
          } else {
            variable _variable = f.getVariable();
            boolean _notEquals_4 = (!Objects.equal(_variable, null));
            if (_notEquals_4) {
              Set<Variable> _variables = this.getVariables(e, b);
              variable _variable_1 = f.getVariable();
              String _name = _variable_1.getName();
              Variable _variable_2 = new Variable(_name);
              Variable variableFound = PascalValidator.<Variable>search(_variables, _variable_2);
              _builder.newLineIfNotEmpty();
              {
                ElementType _type = variableFound.getType();
                boolean _equals_1 = Objects.equal(_type, ElementType.CONSTANT);
                if (_equals_1) {
                  {
                    Type _varType = variableFound.getVarType();
                    String _realType = _varType.getRealType();
                    String _lowerCase_1 = _realType.toLowerCase();
                    boolean _equals_2 = _lowerCase_1.equals("array of char");
                    if (_equals_2) {
                      _builder.append("lea eax, [");
                      Object _value = variableFound.getValue();
                      String _get_2 = this.stringTable.get(((String) _value));
                      _builder.append(_get_2, "");
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                      _builder.append("mov ebx, ");
                      Object _value_1 = variableFound.getValue();
                      String _get_3 = this.stringTable.get(((String) _value_1));
                      _builder.append(_get_3, "");
                      _builder.append("_SIZE");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("mov eax, ");
                      block _containingBlock = variableFound.getContainingBlock();
                      String _name_1 = this.getName(_containingBlock);
                      _builder.append(_name_1, "");
                      _builder.append("_");
                      String _name_2 = variableFound.getName();
                      _builder.append(_name_2, "");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                } else {
                  {
                    ElementType _type_1 = variableFound.getType();
                    boolean _equals_3 = Objects.equal(_type_1, ElementType.FUNCTION_RETURN);
                    if (_equals_3) {
                      _builder.append("mov eax, [");
                      String _extendedName = variableFound.getExtendedName();
                      _builder.append(_extendedName, "");
                      _builder.append("_");
                      block _containingBlock_1 = variableFound.getContainingBlock();
                      String _name_3 = this.getName(_containingBlock_1);
                      _builder.append(_name_3, "");
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("mov eax, [");
                      String _name_4 = variableFound.getName();
                      _builder.append(_name_4, "");
                      _builder.append("_");
                      block _containingBlock_2 = variableFound.getContainingBlock();
                      String _name_5 = this.getName(_containingBlock_2);
                      _builder.append(_name_5, "");
                      _builder.append("]");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            } else {
              function_designator _function = f.getFunction();
              boolean _notEquals_5 = (!Objects.equal(_function, null));
              if (_notEquals_5) {
                function_designator _function_1 = f.getFunction();
                CharSequence _computeFunction = this.computeFunction(e, b, _function_1);
                _builder.append(_computeFunction, "");
                _builder.newLineIfNotEmpty();
              } else {
                expression _expression = f.getExpression();
                boolean _notEquals_6 = (!Objects.equal(_expression, null));
                if (_notEquals_6) {
                  expression _expression_1 = f.getExpression();
                  CharSequence _computeExpression = this.computeExpression(e, b, _expression_1);
                  _builder.append(_computeExpression, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  factor _not = f.getNot();
                  boolean _notEquals_7 = (!Objects.equal(_not, null));
                  if (_notEquals_7) {
                    factor _not_1 = f.getNot();
                    CharSequence _computeFactor = this.computeFactor(e, b, _not_1);
                    _builder.append(_computeFactor, "");
                    _builder.newLineIfNotEmpty();
                    _builder.append("xor eax, 1 ; Logical not");
                    _builder.newLine();
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence computeTerm(final program e, final block b, final term t) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<factor> _factors = t.getFactors();
    factor _get = _factors.get(0);
    CharSequence _computeFactor = this.computeFactor(e, b, _get);
    _builder.append(_computeFactor, "");
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = t.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = t.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<factor> _factors_1 = t.getFactors();
            int _plusPlus = index++;
            factor _get_1 = _factors_1.get(_plusPlus);
            CharSequence _computeFactor_1 = this.computeFactor(e, b, _get_1);
            _builder.append(_computeFactor_1, "");
            _builder.newLineIfNotEmpty();
            {
              String _lowerCase = operator.toLowerCase();
              boolean _equals = _lowerCase.equals("and");
              if (_equals) {
                _builder.append("and ecx, eax ; And");
                _builder.newLine();
              } else {
                String _lowerCase_1 = operator.toLowerCase();
                boolean _equals_1 = _lowerCase_1.equals("mod");
                if (_equals_1) {
                  _builder.append("mov edx, eax ; Module");
                  _builder.newLine();
                  _builder.append("mov eax, ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                  _builder.append("cdq");
                  _builder.newLine();
                  _builder.append("idiv ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                } else {
                  boolean _or = false;
                  String _lowerCase_2 = operator.toLowerCase();
                  boolean _equals_2 = _lowerCase_2.equals("div");
                  if (_equals_2) {
                    _or = true;
                  } else {
                    boolean _equals_3 = operator.equals("/");
                    _or = _equals_3;
                  }
                  if (_or) {
                    _builder.append("mov edx, eax ; Divide");
                    _builder.newLine();
                    _builder.append("mov eax, ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, edx");
                    _builder.newLine();
                    _builder.append("cdq");
                    _builder.newLine();
                    _builder.append("idiv ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, eax");
                    _builder.newLine();
                  } else {
                    boolean _equals_4 = operator.equals("*");
                    if (_equals_4) {
                      _builder.append("mul ecx ; Multiply");
                      _builder.newLine();
                      _builder.append("mov ecx, eax");
                      _builder.newLine();
                    }
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence computeSimpleExpression(final program e, final block b, final simple_expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<EObject> _terms = exp.getTerms();
    EObject _get = _terms.get(0);
    CharSequence _computeTerm = this.computeTerm(e, b, ((term) _get));
    _builder.append(_computeTerm, "");
    _builder.newLineIfNotEmpty();
    {
      String _prefixOperator = exp.getPrefixOperator();
      boolean _notEquals = (!Objects.equal(_prefixOperator, null));
      if (_notEquals) {
        {
          String _prefixOperator_1 = exp.getPrefixOperator();
          boolean _equals = _prefixOperator_1.equals("-");
          if (_equals) {
            _builder.append("neg aex");
            _builder.newLine();
          }
        }
      }
    }
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals_1 = (!Objects.equal(_operators, null));
      if (_notEquals_1) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            {
              EList<EObject> _terms_1 = exp.getTerms();
              EObject _get_1 = _terms_1.get(index);
              if ((_get_1 instanceof term)) {
                EList<EObject> _terms_2 = exp.getTerms();
                int _plusPlus = index++;
                EObject _get_2 = _terms_2.get(_plusPlus);
                CharSequence _computeTerm_1 = this.computeTerm(e, b, ((term) _get_2));
                _builder.append(_computeTerm_1, "");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("mov eax, ");
                EList<EObject> _terms_3 = exp.getTerms();
                int _plusPlus_1 = index++;
                EObject _get_3 = _terms_3.get(_plusPlus_1);
                String _integer = ((any_number) _get_3).getInteger();
                _builder.append(_integer, "");
                _builder.newLineIfNotEmpty();
              }
            }
            {
              boolean _equals_1 = operator.equals("or");
              if (_equals_1) {
                _builder.append("or ecx, eax ; Logical or");
                _builder.newLine();
              } else {
                boolean _equals_2 = operator.equals("+");
                if (_equals_2) {
                  _builder.append("add ecx, eax ; Sum");
                  _builder.newLine();
                } else {
                  boolean _equals_3 = operator.equals("-");
                  if (_equals_3) {
                    _builder.append("sub ecx, eax ; Sub");
                    _builder.newLine();
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence computeExpression(final program e, final block b, final expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<simple_expression> _expressions = exp.getExpressions();
    simple_expression _get = _expressions.get(0);
    CharSequence _computeSimpleExpression = this.computeSimpleExpression(e, b, _get);
    _builder.append(_computeSimpleExpression, "");
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<simple_expression> _expressions_1 = exp.getExpressions();
            int _plusPlus = index++;
            simple_expression _get_1 = _expressions_1.get(_plusPlus);
            CharSequence _computeSimpleExpression_1 = this.computeSimpleExpression(e, b, _get_1);
            _builder.append(_computeSimpleExpression_1, "");
            _builder.newLineIfNotEmpty();
            _builder.append("cmp ecx, eax");
            _builder.newLine();
            {
              boolean _equals = operator.equals("=");
              if (_equals) {
                _builder.append("je .set_to_true");
                _builder.append(this.labelCount, "");
                _builder.append(" ; Equal");
                _builder.newLineIfNotEmpty();
                _builder.append("jmp .set_to_false");
                _builder.append(this.labelCount, "");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _equals_1 = operator.equals(">");
                if (_equals_1) {
                  _builder.append("jg .set_to_true");
                  _builder.append(this.labelCount, "");
                  _builder.append(" ; Greater");
                  _builder.newLineIfNotEmpty();
                  _builder.append("jmp .set_to_false");
                  _builder.append(this.labelCount, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  boolean _equals_2 = operator.equals(">=");
                  if (_equals_2) {
                    _builder.append("jge .set_to_true");
                    _builder.append(this.labelCount, "");
                    _builder.append(" ; Greater or equal");
                    _builder.newLineIfNotEmpty();
                    _builder.append("jmp .set_to_false");
                    _builder.append(this.labelCount, "");
                    _builder.newLineIfNotEmpty();
                  } else {
                    boolean _equals_3 = operator.equals("<");
                    if (_equals_3) {
                      _builder.append("jl .set_to_true");
                      _builder.append(this.labelCount, "");
                      _builder.append(" ; Lesser");
                      _builder.newLineIfNotEmpty();
                      _builder.append("jmp .set_to_false");
                      _builder.append(this.labelCount, "");
                      _builder.newLineIfNotEmpty();
                    } else {
                      boolean _equals_4 = operator.equals("<=");
                      if (_equals_4) {
                        _builder.append("jle .set_to_true");
                        _builder.append(this.labelCount, "");
                        _builder.append(" ; Lesser of equal");
                        _builder.newLineIfNotEmpty();
                        _builder.append("jmp .set_to_false");
                        _builder.append(this.labelCount, "");
                        _builder.newLineIfNotEmpty();
                      } else {
                        boolean _equals_5 = operator.equals("<>");
                        if (_equals_5) {
                          _builder.append("jne .set_to_true");
                          _builder.append(this.labelCount, "");
                          _builder.append(" ; Different");
                          _builder.newLineIfNotEmpty();
                          _builder.append("jmp .set_to_false");
                          _builder.append(this.labelCount, "");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                    }
                  }
                }
              }
            }
            _builder.append(".set_to_true");
            _builder.append(this.labelCount, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 1");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("jmp .out");
            _builder.append(this.labelCount, "\t");
            _builder.newLineIfNotEmpty();
            _builder.append(".set_to_false");
            _builder.append(this.labelCount, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 0");
            _builder.newLine();
            _builder.append(".out");
            int _plusPlus_1 = this.labelCount++;
            _builder.append(_plusPlus_1, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence print(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    {
      expression_list _expressions = function.getExpressions();
      boolean _notEquals = (!Objects.equal(_expressions, null));
      if (_notEquals) {
        expression_list _expressions_1 = function.getExpressions();
        EList<expression> _expressions_2 = _expressions_1.getExpressions();
        expression _get = _expressions_2.get(0);
        CharSequence _computeExpression = this.computeExpression(e, b, _get);
        _builder.append(_computeExpression, "");
        _builder.newLineIfNotEmpty();
        {
          expression_list _expressions_3 = function.getExpressions();
          EList<expression> _expressions_4 = _expressions_3.getExpressions();
          expression _get_1 = _expressions_4.get(0);
          Type _type = this.getType(e, _get_1);
          int _typeWeight = TypeInferer.getTypeWeight(_type);
          boolean _equals = (_typeWeight == 4);
          if (_equals) {
            _builder.append("call _print_float");
            _builder.newLine();
          } else {
            expression_list _expressions_5 = function.getExpressions();
            EList<expression> _expressions_6 = _expressions_5.getExpressions();
            expression _get_2 = _expressions_6.get(0);
            Type _type_1 = this.getType(e, _get_2);
            int _typeWeight_1 = TypeInferer.getTypeWeight(_type_1);
            boolean _greaterEqualsThan = (_typeWeight_1 >= 0);
            if (_greaterEqualsThan) {
              _builder.append("call _print_integer");
              _builder.newLine();
            } else {
              expression_list _expressions_7 = function.getExpressions();
              EList<expression> _expressions_8 = _expressions_7.getExpressions();
              expression _get_3 = _expressions_8.get(0);
              Type _type_2 = this.getType(e, _get_3);
              String _realType = _type_2.getRealType();
              String _lowerCase = _realType.toLowerCase();
              boolean _equals_1 = _lowerCase.equals("boolean");
              if (_equals_1) {
                _builder.append("and eax, 1 ; Setting zero flag");
                _builder.newLine();
                _builder.append("call _print_boolean");
                _builder.newLine();
              } else {
                _builder.append("call _print_string");
                _builder.newLine();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence print(final program e, final String s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("lea eax, [");
    _builder.append(s, "");
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("mov ebx, ");
    _builder.append(s, "");
    _builder.append("_SIZE");
    _builder.newLineIfNotEmpty();
    _builder.append("call _print_string");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compileSequence(final program e, final block b, final statement_sequence sequence) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<statement> _statements = sequence.getStatements();
      for(final statement stmt : _statements) {
        CharSequence _compileStatement = this.compileStatement(e, b, stmt);
        _builder.append(_compileStatement, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileStatement(final program e, final block b, final statement s) {
    StringConcatenation _builder = new StringConcatenation();
    {
      simple_statement _simple = s.getSimple();
      boolean _notEquals = (!Objects.equal(_simple, null));
      if (_notEquals) {
        {
          simple_statement _simple_1 = s.getSimple();
          assignment_statement _assignment = _simple_1.getAssignment();
          boolean _notEquals_1 = (!Objects.equal(_assignment, null));
          if (_notEquals_1) {
            _builder.append("; Assigning ");
            simple_statement _simple_2 = s.getSimple();
            assignment_statement _assignment_1 = _simple_2.getAssignment();
            variable _variable = _assignment_1.getVariable();
            String _name = _variable.getName();
            _builder.append(_name, "");
            _builder.newLineIfNotEmpty();
            simple_statement _simple_3 = s.getSimple();
            assignment_statement _assignment_2 = _simple_3.getAssignment();
            expression _expression = _assignment_2.getExpression();
            CharSequence _computeExpression = this.computeExpression(e, b, _expression);
            _builder.append(_computeExpression, "");
            _builder.newLineIfNotEmpty();
            Set<Variable> _variables = this.getVariables(e, b);
            simple_statement _simple_4 = s.getSimple();
            assignment_statement _assignment_3 = _simple_4.getAssignment();
            variable _variable_1 = _assignment_3.getVariable();
            String _name_1 = _variable_1.getName();
            Variable _variable_2 = new Variable(_name_1);
            Variable variableFound = PascalValidator.<Variable>search(_variables, _variable_2);
            _builder.newLineIfNotEmpty();
            {
              ElementType _type = variableFound.getType();
              boolean _equals = Objects.equal(_type, ElementType.FUNCTION_RETURN);
              if (_equals) {
                _builder.append("mov [");
                String _extendedName = variableFound.getExtendedName();
                _builder.append(_extendedName, "");
                _builder.append("_");
                block _containingBlock = variableFound.getContainingBlock();
                String _name_2 = this.getName(_containingBlock);
                _builder.append(_name_2, "");
                _builder.append("], eax");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("mov [");
                String _name_3 = variableFound.getName();
                _builder.append(_name_3, "");
                _builder.append("_");
                block _containingBlock_1 = variableFound.getContainingBlock();
                String _name_4 = this.getName(_containingBlock_1);
                _builder.append(_name_4, "");
                _builder.append("], eax");
                _builder.newLineIfNotEmpty();
              }
            }
          } else {
            simple_statement _simple_5 = s.getSimple();
            String _function_noargs = _simple_5.getFunction_noargs();
            boolean _notEquals_2 = (!Objects.equal(_function_noargs, null));
            if (_notEquals_2) {
              {
                simple_statement _simple_6 = s.getSimple();
                String _function_noargs_1 = _simple_6.getFunction_noargs();
                boolean _equals_1 = _function_noargs_1.equals("writeln");
                if (_equals_1) {
                  _builder.append("; Call writeln");
                  _builder.newLine();
                  CharSequence _print = this.print(e, "__NEW_LINE");
                  _builder.append(_print, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  _builder.append("; Call ");
                  simple_statement _simple_7 = s.getSimple();
                  String _function_noargs_2 = _simple_7.getFunction_noargs();
                  _builder.append(_function_noargs_2, "");
                  _builder.newLineIfNotEmpty();
                  Set<Procedure> _procedures = this.getProcedures(e, b);
                  simple_statement _simple_8 = s.getSimple();
                  String _function_noargs_3 = _simple_8.getFunction_noargs();
                  ArrayList<Variable> _arrayList = new ArrayList<Variable>();
                  Procedure _procedure = new Procedure(_function_noargs_3, _arrayList);
                  Procedure functionFound = PascalValidator.<Procedure>search(_procedures, _procedure);
                  _builder.newLineIfNotEmpty();
                  _builder.append("call _");
                  String _extendedName_1 = functionFound.getExtendedName();
                  _builder.append(_extendedName_1, "");
                  _builder.append("_");
                  block _containingBlock_2 = functionFound.getContainingBlock();
                  String _name_5 = this.getName(_containingBlock_2);
                  _builder.append(_name_5, "");
                  _builder.newLineIfNotEmpty();
                }
              }
            } else {
              simple_statement _simple_9 = s.getSimple();
              function_designator _function = _simple_9.getFunction();
              boolean _notEquals_3 = (!Objects.equal(_function, null));
              if (_notEquals_3) {
                {
                  simple_statement _simple_10 = s.getSimple();
                  function_designator _function_1 = _simple_10.getFunction();
                  String _name_6 = _function_1.getName();
                  boolean _equals_2 = _name_6.equals("write");
                  if (_equals_2) {
                    _builder.append("; Call write");
                    _builder.newLine();
                    simple_statement _simple_11 = s.getSimple();
                    function_designator _function_2 = _simple_11.getFunction();
                    CharSequence _print_1 = this.print(e, b, _function_2);
                    _builder.append(_print_1, "");
                    _builder.newLineIfNotEmpty();
                  } else {
                    simple_statement _simple_12 = s.getSimple();
                    function_designator _function_3 = _simple_12.getFunction();
                    String _name_7 = _function_3.getName();
                    boolean _equals_3 = _name_7.equals("writeln");
                    if (_equals_3) {
                      _builder.append("; Call writeln");
                      _builder.newLine();
                      simple_statement _simple_13 = s.getSimple();
                      function_designator _function_4 = _simple_13.getFunction();
                      CharSequence _print_2 = this.print(e, b, _function_4);
                      _builder.append(_print_2, "");
                      _builder.newLineIfNotEmpty();
                      CharSequence _print_3 = this.print(e, "__NEW_LINE");
                      _builder.append(_print_3, "");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("; Call ");
                      simple_statement _simple_14 = s.getSimple();
                      function_designator _function_5 = _simple_14.getFunction();
                      String _name_8 = _function_5.getName();
                      _builder.append(_name_8, "");
                      _builder.newLineIfNotEmpty();
                      simple_statement _simple_15 = s.getSimple();
                      function_designator _function_6 = _simple_15.getFunction();
                      CharSequence _computeFunction = this.computeFunction(e, b, _function_6);
                      _builder.append(_computeFunction, "");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        structured_statement _structured = s.getStructured();
        boolean _notEquals_4 = (!Objects.equal(_structured, null));
        if (_notEquals_4) {
          {
            structured_statement _structured_1 = s.getStructured();
            compound_statement _compound = _structured_1.getCompound();
            boolean _notEquals_5 = (!Objects.equal(_compound, null));
            if (_notEquals_5) {
              _builder.append("; Block");
              _builder.newLine();
              structured_statement _structured_2 = s.getStructured();
              compound_statement _compound_1 = _structured_2.getCompound();
              statement_sequence _sequence = _compound_1.getSequence();
              CharSequence _compileSequence = this.compileSequence(e, b, _sequence);
              _builder.append(_compileSequence, "");
              _builder.newLineIfNotEmpty();
            } else {
              structured_statement _structured_3 = s.getStructured();
              repetitive_statement _repetitive = _structured_3.getRepetitive();
              boolean _notEquals_6 = (!Objects.equal(_repetitive, null));
              if (_notEquals_6) {
                _builder.newLine();
              } else {
                structured_statement _structured_4 = s.getStructured();
                conditional_statement _conditional = _structured_4.getConditional();
                boolean _notEquals_7 = (!Objects.equal(_conditional, null));
                if (_notEquals_7) {
                  {
                    structured_statement _structured_5 = s.getStructured();
                    conditional_statement _conditional_1 = _structured_5.getConditional();
                    if_statement _ifStmt = _conditional_1.getIfStmt();
                    boolean _notEquals_8 = (!Objects.equal(_ifStmt, null));
                    if (_notEquals_8) {
                      _builder.append("; If statement");
                      _builder.newLine();
                      structured_statement _structured_6 = s.getStructured();
                      conditional_statement _conditional_2 = _structured_6.getConditional();
                      if_statement ifStmt = _conditional_2.getIfStmt();
                      _builder.newLineIfNotEmpty();
                      expression _expression_1 = ifStmt.getExpression();
                      CharSequence _computeExpression_1 = this.computeExpression(e, b, _expression_1);
                      _builder.append(_computeExpression_1, "");
                      _builder.newLineIfNotEmpty();
                      _builder.append("and eax, 1 ; Setting zero flag");
                      _builder.newLine();
                      int label = this.conditionalLabelCount++;
                      _builder.newLineIfNotEmpty();
                      _builder.append("jz .else_body");
                      _builder.append(label, "");
                      _builder.newLineIfNotEmpty();
                      _builder.append(".if_body");
                      _builder.append(label, "");
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t");
                      statement _ifStatement = ifStmt.getIfStatement();
                      CharSequence _compileStatement = this.compileStatement(e, b, _ifStatement);
                      _builder.append(_compileStatement, "\t");
                      _builder.newLineIfNotEmpty();
                      _builder.append("\t");
                      _builder.append("jmp .conditional_out");
                      _builder.append(label, "\t");
                      _builder.newLineIfNotEmpty();
                      _builder.append(".else_body");
                      _builder.append(label, "");
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                      {
                        statement _elseStatement = ifStmt.getElseStatement();
                        boolean _notEquals_9 = (!Objects.equal(_elseStatement, null));
                        if (_notEquals_9) {
                          _builder.append("\t");
                          statement _elseStatement_1 = ifStmt.getElseStatement();
                          CharSequence _compileStatement_1 = this.compileStatement(e, b, _elseStatement_1);
                          _builder.append(_compileStatement_1, "\t");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                      _builder.append(".conditional_out");
                      _builder.append(label, "");
                      _builder.append(":");
                      _builder.newLineIfNotEmpty();
                    } else {
                      structured_statement _structured_7 = s.getStructured();
                      conditional_statement _conditional_3 = _structured_7.getConditional();
                      case_statement _caseStmt = _conditional_3.getCaseStmt();
                      boolean _notEquals_10 = (!Objects.equal(_caseStmt, null));
                      if (_notEquals_10) {
                        _builder.append("; Case statement");
                        _builder.newLine();
                        structured_statement _structured_8 = s.getStructured();
                        conditional_statement _conditional_4 = _structured_8.getConditional();
                        case_statement caseStmt = _conditional_4.getCaseStmt();
                        _builder.newLineIfNotEmpty();
                        int globalLabel = this.caseGlobalLabelCount++;
                        _builder.newLineIfNotEmpty();
                        expression _expression_2 = caseStmt.getExpression();
                        CharSequence _computeExpression_2 = this.computeExpression(e, b, _expression_2);
                        _builder.append(_computeExpression_2, "");
                        _builder.newLineIfNotEmpty();
                        {
                          EList<case_limb> _cases = caseStmt.getCases();
                          for(final case_limb c : _cases) {
                            _builder.append("; Case limb");
                            _builder.newLine();
                            int label_1 = this.caseLabelCount++;
                            _builder.newLineIfNotEmpty();
                            {
                              case_label_list _cases_1 = c.getCases();
                              EList<constant> _constants = _cases_1.getConstants();
                              for(final constant constant : _constants) {
                                _builder.append("; Comparison with constant");
                                _builder.newLine();
                                _builder.append("mov ecx, ");
                                Object _value = this.getValue(e, b, constant);
                                _builder.append(_value, "");
                                _builder.newLineIfNotEmpty();
                                _builder.append("cmp eax, ecx");
                                _builder.newLine();
                                _builder.append("je .case_limb_body");
                                _builder.append(label_1, "");
                                _builder.newLineIfNotEmpty();
                              }
                            }
                            _builder.append("jmp .case_limb_out");
                            _builder.append(label_1, "");
                            _builder.newLineIfNotEmpty();
                            _builder.append(".case_limb_body");
                            _builder.append(label_1, "");
                            _builder.append(":");
                            _builder.newLineIfNotEmpty();
                            _builder.append("\t");
                            statement _statement = c.getStatement();
                            CharSequence _compileStatement_2 = this.compileStatement(e, b, _statement);
                            _builder.append(_compileStatement_2, "\t");
                            _builder.newLineIfNotEmpty();
                            _builder.append("\t");
                            _builder.append("jmp .case_out");
                            _builder.append(globalLabel, "\t");
                            _builder.newLineIfNotEmpty();
                            _builder.append(".case_limb_out");
                            _builder.append(label_1, "");
                            _builder.append(":");
                            _builder.newLineIfNotEmpty();
                          }
                        }
                        _builder.append(".case_out");
                        _builder.append(globalLabel, "");
                        _builder.append(":");
                        _builder.newLineIfNotEmpty();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
}
