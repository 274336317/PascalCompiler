/**
 * generated by Xtext
 */
package org.xtext.example.pascal.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.pascal.pascal.any_number;
import org.xtext.example.pascal.pascal.assignment_statement;
import org.xtext.example.pascal.pascal.block;
import org.xtext.example.pascal.pascal.expression;
import org.xtext.example.pascal.pascal.expression_list;
import org.xtext.example.pascal.pascal.factor;
import org.xtext.example.pascal.pascal.function_designator;
import org.xtext.example.pascal.pascal.number;
import org.xtext.example.pascal.pascal.program;
import org.xtext.example.pascal.pascal.program_heading_block;
import org.xtext.example.pascal.pascal.simple_expression;
import org.xtext.example.pascal.pascal.simple_statement;
import org.xtext.example.pascal.pascal.statement;
import org.xtext.example.pascal.pascal.statement_part;
import org.xtext.example.pascal.pascal.statement_sequence;
import org.xtext.example.pascal.pascal.term;
import org.xtext.example.pascal.pascal.variable;
import org.xtext.example.pascal.validation.ComposedType;
import org.xtext.example.pascal.validation.ComposedTypeKind;
import org.xtext.example.pascal.validation.ElementType;
import org.xtext.example.pascal.validation.PascalValidator;
import org.xtext.example.pascal.validation.Type;
import org.xtext.example.pascal.validation.TypeInferer;
import org.xtext.example.pascal.validation.Variable;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class PascalGenerator implements IGenerator {
  private HashMap<String, String> stringTable = new HashMap<String, String>();
  
  private int labelCount;
  
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<program> _filter = Iterables.<program>filter(_iterable, program.class);
    for (final program e : _filter) {
      {
        this.labelCount = 0;
        program_heading_block _heading = e.getHeading();
        String _name = _heading.getName();
        String _plus = (_name + ".asm");
        CharSequence _compile = this.compile(e);
        fsa.generateFile(_plus, _compile);
      }
    }
  }
  
  public void createStringTable(final program e) {
    this.stringTable.clear();
    TreeIterator<EObject> _eAllContents = e.eAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_eAllContents);
    Iterable<factor> _filter = Iterables.<factor>filter(_iterable, factor.class);
    for (final factor s : _filter) {
      String _string = s.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        String _string_1 = s.getString();
        boolean _containsKey = this.stringTable.containsKey(_string_1);
        boolean _not = (!_containsKey);
        if (_not) {
          String _string_2 = s.getString();
          int _size = this.stringTable.size();
          String _plus = ("__STRING_" + Integer.valueOf(_size));
          this.stringTable.put(_string_2, _plus);
        }
      }
    }
  }
  
  public Set<Variable> getVariables(final program e, final block b) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("variables");
    Map<block, Set<Variable>> map = ((Map<block, Set<Variable>>) _get);
    this.createStringTable(e);
    return map.get(b);
  }
  
  public int getNumberOfBytes(final Type t) {
    String _realType = t.getRealType();
    String type = _realType.toLowerCase();
    boolean _or = false;
    boolean _equals = type.equals("boolean");
    if (_equals) {
      _or = true;
    } else {
      boolean _equals_1 = type.equals("shortint");
      _or = _equals_1;
    }
    if (_or) {
      return 1;
    } else {
      boolean _equals_2 = type.equals("char");
      if (_equals_2) {
        return 2;
      } else {
        boolean _equals_3 = type.equals("integer");
        if (_equals_3) {
          return 4;
        } else {
          boolean _or_1 = false;
          boolean _equals_4 = type.equals("longint");
          if (_equals_4) {
            _or_1 = true;
          } else {
            boolean _equals_5 = type.equals("real");
            _or_1 = _equals_5;
          }
          if (_or_1) {
            return 8;
          }
        }
      }
    }
    return 4;
  }
  
  public int getNumberOfBytes(final Variable v) {
    Type _varType = v.getVarType();
    return this.getNumberOfBytes(_varType);
  }
  
  public Object getValue(final Variable v) {
    Object _value = v.getValue();
    if ((_value instanceof String)) {
      Object _value_1 = v.getValue();
      String _string = _value_1.toString();
      String _replaceAll = _string.replaceAll("\'", "\"");
      String _plus = ("\'" + _replaceAll);
      return (_plus + "\'");
    } else {
      Object _value_2 = v.getValue();
      if ((_value_2 instanceof Boolean)) {
        Object _value_3 = v.getValue();
        boolean _equals = _value_3.equals(Boolean.valueOf(true));
        if (_equals) {
          return Integer.valueOf(1);
        } else {
          return Integer.valueOf(0);
        }
      }
    }
    return v.getValue();
  }
  
  public Type getType(final program e, final expression expr) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("calculatedTypes");
    Map<EObject, Type> map = ((Map<EObject, Type>) _get);
    return map.get(expr);
  }
  
  public Variable searchVariable(final program e, final block b, final variable v) {
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    Map<String, Object> artefacts = PascalValidator.artefacts.get(_name);
    Object _get = artefacts.get("variables");
    Map<block, Set<Variable>> map = ((Map<block, Set<Variable>>) _get);
    Set<Variable> variables = map.get(b);
    for (final Variable myVar : variables) {
      String _name_1 = myVar.getName();
      String _lowerCase = _name_1.toLowerCase();
      String _name_2 = v.getName();
      String _lowerCase_1 = _name_2.toLowerCase();
      boolean _equals = _lowerCase.equals(_lowerCase_1);
      if (_equals) {
        return myVar;
      }
    }
    return null;
  }
  
  public Type getType(final program e, final block b, final variable v) {
    Variable variableFound = this.searchVariable(e, b, v);
    boolean _notEquals = (!Objects.equal(variableFound, null));
    if (_notEquals) {
      return variableFound.getVarType();
    }
    return new Type("nil");
  }
  
  public boolean isConstant(final program e, final block b, final variable v) {
    Variable variableFound = this.searchVariable(e, b, v);
    boolean _notEquals = (!Objects.equal(variableFound, null));
    if (_notEquals) {
      ElementType _type = variableFound.getType();
      return Objects.equal(_type, ElementType.CONSTANT);
    }
    return false;
  }
  
  public CharSequence printString(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print string");
    _builder.newLine();
    _builder.append("_print_string:");
    _builder.newLine();
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("push ebx ");
    _builder.newLine();
    _builder.append("sub esp, ebx");
    _builder.newLine();
    _builder.append("mov [esp], dword eax");
    _builder.newLine();
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("add esp, ebx");
    _builder.newLine();
    _builder.append("pop eax ");
    _builder.newLine();
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printInteger(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print integer");
    _builder.newLine();
    _builder.append("_print_integer:");
    _builder.newLine();
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("lea eax, [__PRINTF_I]");
    _builder.newLine();
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("add esp, 4");
    _builder.newLine();
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("ret ;return ");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printBoolean(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print boolean");
    _builder.newLine();
    _builder.append("_print_boolean:");
    _builder.newLine();
    _builder.append("jnz .print_boolean_true");
    _builder.newLine();
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("push ebx ");
    _builder.newLine();
    CharSequence _print = this.print(e, "__BOOLEAN_FALSE");
    _builder.append(_print, "");
    _builder.newLineIfNotEmpty();
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.append(".print_boolean_true:");
    _builder.newLine();
    _builder.append("push eax");
    _builder.newLine();
    _builder.append("push ebx ");
    _builder.newLine();
    CharSequence _print_1 = this.print(e, "__BOOLEAN_TRUE");
    _builder.append(_print_1, "");
    _builder.newLineIfNotEmpty();
    _builder.append("pop eax");
    _builder.newLine();
    _builder.append("pop ebx");
    _builder.newLine();
    _builder.append("ret ;return");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence printFloat(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Print float");
    _builder.newLine();
    _builder.append("_print_float:");
    _builder.newLine();
    _builder.append("push eax ");
    _builder.newLine();
    _builder.append("sub esp, 8");
    _builder.newLine();
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("sub esp, 4");
    _builder.newLine();
    _builder.append("lea eax, [__PRINTF_F]");
    _builder.newLine();
    _builder.append("mov [esp], eax");
    _builder.newLine();
    _builder.append("call _printf");
    _builder.newLine();
    _builder.append("add esp, 12");
    _builder.newLine();
    _builder.append("pop eax ");
    _builder.newLine();
    _builder.append("ret ;return ");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compilePredefinedProcedures(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _printString = this.printString(e);
    _builder.append(_printString, "");
    _builder.newLineIfNotEmpty();
    CharSequence _printInteger = this.printInteger(e);
    _builder.append(_printInteger, "");
    _builder.newLineIfNotEmpty();
    CharSequence _printBoolean = this.printBoolean(e);
    _builder.append(_printBoolean, "");
    _builder.newLineIfNotEmpty();
    CharSequence _printFloat = this.printFloat(e);
    _builder.append(_printFloat, "");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence compile(final program e) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Program ");
    program_heading_block _heading = e.getHeading();
    String _name = _heading.getName();
    _builder.append(_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("global _main");
    _builder.newLine();
    _builder.newLine();
    _builder.append("extern _printf");
    _builder.newLine();
    _builder.append("extern _scanf ");
    _builder.newLine();
    _builder.newLine();
    block _block = e.getBlock();
    block _block_1 = e.getBlock();
    Set<Variable> _variables = this.getVariables(e, _block_1);
    CharSequence _compile = this.compile(e, _block, _variables);
    _builder.append(_compile, "");
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("; Code");
    _builder.newLine();
    _builder.append("section .text");
    _builder.newLine();
    _builder.newLine();
    CharSequence _compilePredefinedProcedures = this.compilePredefinedProcedures(e);
    _builder.append(_compilePredefinedProcedures, "");
    _builder.newLineIfNotEmpty();
    _builder.append("_main:");
    _builder.newLine();
    block _block_2 = e.getBlock();
    block _block_3 = e.getBlock();
    statement_part _statement = _block_3.getStatement();
    CharSequence _compile_1 = this.compile(e, _block_2, _statement);
    _builder.append(_compile_1, "");
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.append("ret\t; Exit program");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final program e, final block b, final Set<Variable> variables) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("; Loading global constants and strings");
    _builder.newLine();
    _builder.append("section .data");
    _builder.newLine();
    _builder.append("__NEW_LINE db 10, 0");
    _builder.newLine();
    _builder.append("__NEW_LINE_SIZE equ $-__NEW_LINE");
    _builder.newLine();
    _builder.append("__PRINTF_S db \'%s\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_I db \'%d\', 0");
    _builder.newLine();
    _builder.append("__PRINTF_F db \'%f\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE db \'true\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_TRUE_SIZE equ $-__BOOLEAN_TRUE");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE db \'false\', 0");
    _builder.newLine();
    _builder.append("__BOOLEAN_FALSE_SIZE equ $-__BOOLEAN_FALSE");
    _builder.newLine();
    {
      Set<String> _keySet = this.stringTable.keySet();
      for(final String s : _keySet) {
        String _get = this.stringTable.get(s);
        Type _type = new Type("char");
        ComposedType _composedType = new ComposedType(_type, 
          ComposedTypeKind.ARRAY);
        Variable _variable = new Variable(_get, _composedType, false, ElementType.CONSTANT, s);
        CharSequence _compileGlobalConstant = this.compileGlobalConstant(e, _variable, b);
        _builder.append(_compileGlobalConstant, "");
        _builder.newLineIfNotEmpty();
      }
    }
    {
      for(final Variable v : variables) {
        CharSequence _compileGlobalConstant_1 = this.compileGlobalConstant(e, v, b);
        _builder.append(_compileGlobalConstant_1, "");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("; Loading global variables");
    _builder.newLine();
    _builder.append("section .bss");
    _builder.newLine();
    {
      for(final Variable v_1 : variables) {
        CharSequence _compileGlobalVariables = this.compileGlobalVariables(e, v_1, b);
        _builder.append(_compileGlobalVariables, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compileGlobalConstant(final program e, final Variable v, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    {
      ElementType _type = v.getType();
      boolean _equals = Objects.equal(_type, ElementType.CONSTANT);
      if (_equals) {
        {
          Type _varType = v.getVarType();
          String _realType = _varType.getRealType();
          String _lowerCase = _realType.toLowerCase();
          boolean _equals_1 = _lowerCase.equals("array of char");
          if (_equals_1) {
            String _name = v.getName();
            _builder.append(_name, "");
            _builder.append(" db ");
            Object _value = this.getValue(v);
            _builder.append(_value, "");
            _builder.append(", 0");
            _builder.newLineIfNotEmpty();
            String _name_1 = v.getName();
            _builder.append(_name_1, "");
            _builder.append("_SIZE equ $-");
            String _name_2 = v.getName();
            _builder.append(_name_2, "");
            _builder.newLineIfNotEmpty();
          } else {
            String _name_3 = v.getName();
            _builder.append(_name_3, "");
            _builder.append(" equ ");
            Object _value_1 = this.getValue(v);
            _builder.append(_value_1, "");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence compileGlobalVariables(final program e, final Variable v, final block b) {
    StringConcatenation _builder = new StringConcatenation();
    {
      ElementType _type = v.getType();
      boolean _equals = Objects.equal(_type, ElementType.VARIABLE);
      if (_equals) {
        String _name = v.getName();
        _builder.append(_name, "");
        _builder.append(" RESB ");
        int _numberOfBytes = this.getNumberOfBytes(v);
        _builder.append(_numberOfBytes, "");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence computeFunction(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder;
  }
  
  public CharSequence computeFactor(final program e, final block b, final factor f) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _string = f.getString();
      boolean _notEquals = (!Objects.equal(_string, null));
      if (_notEquals) {
        _builder.append("lea eax, [");
        String _string_1 = f.getString();
        String _get = this.stringTable.get(_string_1);
        _builder.append(_get, "");
        _builder.append("]");
        _builder.newLineIfNotEmpty();
        _builder.append("mov ebx, ");
        String _string_2 = f.getString();
        String _get_1 = this.stringTable.get(_string_2);
        _builder.append(_get_1, "");
        _builder.append("_SIZE");
        _builder.newLineIfNotEmpty();
      } else {
        number _number = f.getNumber();
        boolean _notEquals_1 = (!Objects.equal(_number, null));
        if (_notEquals_1) {
          {
            number _number_1 = f.getNumber();
            any_number _number_2 = _number_1.getNumber();
            String _integer = _number_2.getInteger();
            boolean _notEquals_2 = (!Objects.equal(_integer, null));
            if (_notEquals_2) {
              _builder.append("mov eax, ");
              number _number_3 = f.getNumber();
              any_number _number_4 = _number_3.getNumber();
              String _integer_1 = _number_4.getInteger();
              _builder.append(_integer_1, "");
              _builder.newLineIfNotEmpty();
            } else {
            }
          }
        } else {
          String _boolean = f.getBoolean();
          boolean _notEquals_3 = (!Objects.equal(_boolean, null));
          if (_notEquals_3) {
            {
              String _boolean_1 = f.getBoolean();
              String _lowerCase = _boolean_1.toLowerCase();
              boolean _equals = _lowerCase.equals("true");
              if (_equals) {
                _builder.append("mov eax, 1");
                _builder.newLine();
              } else {
                _builder.append("mov eax, 0");
                _builder.newLine();
              }
            }
          } else {
            variable _variable = f.getVariable();
            boolean _notEquals_4 = (!Objects.equal(_variable, null));
            if (_notEquals_4) {
              {
                variable _variable_1 = f.getVariable();
                boolean _isConstant = this.isConstant(e, b, _variable_1);
                if (_isConstant) {
                  _builder.append("mov eax, ");
                  variable _variable_2 = f.getVariable();
                  String _name = _variable_2.getName();
                  _builder.append(_name, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  _builder.append("mov eax, [");
                  variable _variable_3 = f.getVariable();
                  String _name_1 = _variable_3.getName();
                  _builder.append(_name_1, "");
                  _builder.append("]");
                  _builder.newLineIfNotEmpty();
                }
              }
              {
                variable _variable_4 = f.getVariable();
                Type _type = this.getType(e, b, _variable_4);
                String _realType = _type.getRealType();
                String _lowerCase_1 = _realType.toLowerCase();
                boolean _equals_1 = _lowerCase_1.equals("array of char");
                if (_equals_1) {
                  _builder.append("mov ebx, ");
                  variable _variable_5 = f.getVariable();
                  String _name_2 = _variable_5.getName();
                  _builder.append(_name_2, "");
                  _builder.append("_SIZE");
                  _builder.newLineIfNotEmpty();
                }
              }
            } else {
              function_designator _function = f.getFunction();
              boolean _notEquals_5 = (!Objects.equal(_function, null));
              if (_notEquals_5) {
                function_designator _function_1 = f.getFunction();
                CharSequence _computeFunction = this.computeFunction(e, b, _function_1);
                _builder.append(_computeFunction, "");
                _builder.newLineIfNotEmpty();
              } else {
                expression _expression = f.getExpression();
                boolean _notEquals_6 = (!Objects.equal(_expression, null));
                if (_notEquals_6) {
                  expression _expression_1 = f.getExpression();
                  CharSequence _computeExpression = this.computeExpression(e, b, _expression_1);
                  _builder.append(_computeExpression, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  factor _not = f.getNot();
                  boolean _notEquals_7 = (!Objects.equal(_not, null));
                  if (_notEquals_7) {
                    factor _not_1 = f.getNot();
                    CharSequence _computeFactor = this.computeFactor(e, b, _not_1);
                    _builder.append(_computeFactor, "");
                    _builder.newLineIfNotEmpty();
                    _builder.append("xor eax, 1 ; Logical not");
                    _builder.newLine();
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence computeTerm(final program e, final block b, final term t) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<factor> _factors = t.getFactors();
    factor _get = _factors.get(0);
    CharSequence _computeFactor = this.computeFactor(e, b, _get);
    _builder.append(_computeFactor, "");
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = t.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = t.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<factor> _factors_1 = t.getFactors();
            int _plusPlus = index++;
            factor _get_1 = _factors_1.get(_plusPlus);
            CharSequence _computeFactor_1 = this.computeFactor(e, b, _get_1);
            _builder.append(_computeFactor_1, "");
            _builder.newLineIfNotEmpty();
            {
              String _lowerCase = operator.toLowerCase();
              boolean _equals = _lowerCase.equals("and");
              if (_equals) {
                _builder.append("and ecx, eax ; And");
                _builder.newLine();
              } else {
                String _lowerCase_1 = operator.toLowerCase();
                boolean _equals_1 = _lowerCase_1.equals("mod");
                if (_equals_1) {
                  _builder.append("mov edx, eax ; Module");
                  _builder.newLine();
                  _builder.append("mov eax, ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                  _builder.append("cdq");
                  _builder.newLine();
                  _builder.append("idiv ecx");
                  _builder.newLine();
                  _builder.append("mov ecx, edx");
                  _builder.newLine();
                } else {
                  boolean _or = false;
                  String _lowerCase_2 = operator.toLowerCase();
                  boolean _equals_2 = _lowerCase_2.equals("div");
                  if (_equals_2) {
                    _or = true;
                  } else {
                    boolean _equals_3 = operator.equals("/");
                    _or = _equals_3;
                  }
                  if (_or) {
                    _builder.append("mov edx, eax ; Divide");
                    _builder.newLine();
                    _builder.append("mov eax, ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, edx");
                    _builder.newLine();
                    _builder.append("cdq");
                    _builder.newLine();
                    _builder.append("idiv ecx");
                    _builder.newLine();
                    _builder.append("mov ecx, eax");
                    _builder.newLine();
                  } else {
                    boolean _equals_4 = operator.equals("*");
                    if (_equals_4) {
                      _builder.append("mul ecx ; Multiply");
                      _builder.newLine();
                      _builder.append("mov ecx, eax");
                      _builder.newLine();
                    }
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence computeSimpleExpression(final program e, final block b, final simple_expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<EObject> _terms = exp.getTerms();
    EObject _get = _terms.get(0);
    CharSequence _computeTerm = this.computeTerm(e, b, ((term) _get));
    _builder.append(_computeTerm, "");
    _builder.newLineIfNotEmpty();
    {
      String _prefixOperator = exp.getPrefixOperator();
      boolean _notEquals = (!Objects.equal(_prefixOperator, null));
      if (_notEquals) {
        {
          String _prefixOperator_1 = exp.getPrefixOperator();
          boolean _equals = _prefixOperator_1.equals("-");
          if (_equals) {
            _builder.append("neg aex");
            _builder.newLine();
          }
        }
      }
    }
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals_1 = (!Objects.equal(_operators, null));
      if (_notEquals_1) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            {
              EList<EObject> _terms_1 = exp.getTerms();
              EObject _get_1 = _terms_1.get(index);
              if ((_get_1 instanceof term)) {
                EList<EObject> _terms_2 = exp.getTerms();
                int _plusPlus = index++;
                EObject _get_2 = _terms_2.get(_plusPlus);
                CharSequence _computeTerm_1 = this.computeTerm(e, b, ((term) _get_2));
                _builder.append(_computeTerm_1, "");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("mov eax, ");
                EList<EObject> _terms_3 = exp.getTerms();
                int _plusPlus_1 = index++;
                EObject _get_3 = _terms_3.get(_plusPlus_1);
                String _integer = ((any_number) _get_3).getInteger();
                _builder.append(_integer, "");
                _builder.newLineIfNotEmpty();
              }
            }
            {
              boolean _equals_1 = operator.equals("or");
              if (_equals_1) {
                _builder.append("or ecx, eax ; Logical or");
                _builder.newLine();
              } else {
                boolean _equals_2 = operator.equals("+");
                if (_equals_2) {
                  _builder.append("add ecx, eax ; Sum");
                  _builder.newLine();
                } else {
                  boolean _equals_3 = operator.equals("-");
                  if (_equals_3) {
                    _builder.append("sub ecx, eax ; Sub");
                    _builder.newLine();
                  }
                }
              }
            }
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence computeExpression(final program e, final block b, final expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("push ecx");
    _builder.newLine();
    EList<simple_expression> _expressions = exp.getExpressions();
    simple_expression _get = _expressions.get(0);
    CharSequence _computeSimpleExpression = this.computeSimpleExpression(e, b, _get);
    _builder.append(_computeSimpleExpression, "");
    _builder.newLineIfNotEmpty();
    {
      EList<String> _operators = exp.getOperators();
      boolean _notEquals = (!Objects.equal(_operators, null));
      if (_notEquals) {
        int index = 1;
        _builder.newLineIfNotEmpty();
        {
          EList<String> _operators_1 = exp.getOperators();
          for(final String operator : _operators_1) {
            _builder.append("mov ecx, eax");
            _builder.newLine();
            EList<simple_expression> _expressions_1 = exp.getExpressions();
            int _plusPlus = index++;
            simple_expression _get_1 = _expressions_1.get(_plusPlus);
            CharSequence _computeSimpleExpression_1 = this.computeSimpleExpression(e, b, _get_1);
            _builder.append(_computeSimpleExpression_1, "");
            _builder.newLineIfNotEmpty();
            _builder.append("cmp ecx, eax");
            _builder.newLine();
            {
              boolean _equals = operator.equals("=");
              if (_equals) {
                _builder.append("jeq .set_to_true");
                _builder.append(this.labelCount, "");
                _builder.newLineIfNotEmpty();
                _builder.append("jmp .set_to_false");
                _builder.append(this.labelCount, "");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _equals_1 = operator.equals(">");
                if (_equals_1) {
                  _builder.append("jg .set_to_true");
                  _builder.append(this.labelCount, "");
                  _builder.newLineIfNotEmpty();
                  _builder.append("jmp .set_to_false");
                  _builder.append(this.labelCount, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  boolean _equals_2 = operator.equals(">=");
                  if (_equals_2) {
                    _builder.append("jge .set_to_true");
                    _builder.append(this.labelCount, "");
                    _builder.newLineIfNotEmpty();
                    _builder.append("jmp .set_to_false");
                    _builder.append(this.labelCount, "");
                    _builder.newLineIfNotEmpty();
                  } else {
                    boolean _equals_3 = operator.equals("<");
                    if (_equals_3) {
                      _builder.append("jl .set_to_true");
                      _builder.append(this.labelCount, "");
                      _builder.newLineIfNotEmpty();
                      _builder.append("jmp .set_to_false");
                      _builder.append(this.labelCount, "");
                      _builder.newLineIfNotEmpty();
                    } else {
                      boolean _equals_4 = operator.equals("<=");
                      if (_equals_4) {
                        _builder.append("jle .set_to_true");
                        _builder.append(this.labelCount, "");
                        _builder.newLineIfNotEmpty();
                        _builder.append("jmp .set_to_false");
                        _builder.append(this.labelCount, "");
                        _builder.newLineIfNotEmpty();
                      } else {
                        boolean _equals_5 = operator.equals("<>");
                        if (_equals_5) {
                          _builder.append("jne .set_to_true");
                          _builder.append(this.labelCount, "");
                          _builder.newLineIfNotEmpty();
                          _builder.append("jmp .set_to_false");
                          _builder.append(this.labelCount, "");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                    }
                  }
                }
              }
            }
            _builder.append(".set_to_true");
            _builder.append(this.labelCount, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 1");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("jmp .out");
            _builder.append(this.labelCount, "\t");
            _builder.newLineIfNotEmpty();
            _builder.append(".set_to_false");
            _builder.append(this.labelCount, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov ecx, 0");
            _builder.newLine();
            _builder.append(".out");
            int _plusPlus_1 = this.labelCount++;
            _builder.append(_plusPlus_1, "");
            _builder.append(":");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("mov eax, ecx");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append("pop ecx");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence print(final program e, final block b, final function_designator function) {
    StringConcatenation _builder = new StringConcatenation();
    {
      expression_list _expressions = function.getExpressions();
      boolean _notEquals = (!Objects.equal(_expressions, null));
      if (_notEquals) {
        expression_list _expressions_1 = function.getExpressions();
        EList<expression> _expressions_2 = _expressions_1.getExpressions();
        expression _get = _expressions_2.get(0);
        CharSequence _computeExpression = this.computeExpression(e, b, _get);
        _builder.append(_computeExpression, "");
        _builder.newLineIfNotEmpty();
        {
          expression_list _expressions_3 = function.getExpressions();
          EList<expression> _expressions_4 = _expressions_3.getExpressions();
          expression _get_1 = _expressions_4.get(0);
          Type _type = this.getType(e, _get_1);
          int _typeWeight = TypeInferer.getTypeWeight(_type);
          boolean _equals = (_typeWeight == 4);
          if (_equals) {
            _builder.append("call _print_float");
            _builder.newLine();
          } else {
            expression_list _expressions_5 = function.getExpressions();
            EList<expression> _expressions_6 = _expressions_5.getExpressions();
            expression _get_2 = _expressions_6.get(0);
            Type _type_1 = this.getType(e, _get_2);
            int _typeWeight_1 = TypeInferer.getTypeWeight(_type_1);
            boolean _greaterEqualsThan = (_typeWeight_1 >= 0);
            if (_greaterEqualsThan) {
              _builder.append("call _print_integer");
              _builder.newLine();
            } else {
              expression_list _expressions_7 = function.getExpressions();
              EList<expression> _expressions_8 = _expressions_7.getExpressions();
              expression _get_3 = _expressions_8.get(0);
              Type _type_2 = this.getType(e, _get_3);
              String _realType = _type_2.getRealType();
              String _lowerCase = _realType.toLowerCase();
              boolean _equals_1 = _lowerCase.equals("boolean");
              if (_equals_1) {
                _builder.append("and eax, 1 ; Setting zero flag");
                _builder.newLine();
                _builder.append("call _print_boolean");
                _builder.newLine();
              } else {
                _builder.append("call _print_string");
                _builder.newLine();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence print(final program e, final String s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("lea eax, [");
    _builder.append(s, "");
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("mov ebx, ");
    _builder.append(s, "");
    _builder.append("_SIZE");
    _builder.newLineIfNotEmpty();
    _builder.append("call _print_string");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final program e, final block b, final statement_part part) {
    StringConcatenation _builder = new StringConcatenation();
    {
      statement_sequence _sequence = part.getSequence();
      EList<statement> _statements = _sequence.getStatements();
      for(final statement s : _statements) {
        {
          simple_statement _simple = s.getSimple();
          boolean _notEquals = (!Objects.equal(_simple, null));
          if (_notEquals) {
            {
              simple_statement _simple_1 = s.getSimple();
              assignment_statement _assignment = _simple_1.getAssignment();
              boolean _notEquals_1 = (!Objects.equal(_assignment, null));
              if (_notEquals_1) {
                _builder.append("; Assigning ");
                simple_statement _simple_2 = s.getSimple();
                assignment_statement _assignment_1 = _simple_2.getAssignment();
                variable _variable = _assignment_1.getVariable();
                String _name = _variable.getName();
                _builder.append(_name, "");
                _builder.newLineIfNotEmpty();
                simple_statement _simple_3 = s.getSimple();
                assignment_statement _assignment_2 = _simple_3.getAssignment();
                expression _expression = _assignment_2.getExpression();
                CharSequence _computeExpression = this.computeExpression(e, b, _expression);
                _builder.append(_computeExpression, "");
                _builder.newLineIfNotEmpty();
                _builder.append("mov [");
                simple_statement _simple_4 = s.getSimple();
                assignment_statement _assignment_3 = _simple_4.getAssignment();
                variable _variable_1 = _assignment_3.getVariable();
                String _name_1 = _variable_1.getName();
                _builder.append(_name_1, "");
                _builder.append("], eax");
                _builder.newLineIfNotEmpty();
              } else {
                simple_statement _simple_5 = s.getSimple();
                String _function_noargs = _simple_5.getFunction_noargs();
                boolean _notEquals_2 = (!Objects.equal(_function_noargs, null));
                if (_notEquals_2) {
                  {
                    simple_statement _simple_6 = s.getSimple();
                    String _function_noargs_1 = _simple_6.getFunction_noargs();
                    boolean _equals = _function_noargs_1.equals("writeln");
                    if (_equals) {
                      _builder.append("; Call writeln");
                      _builder.newLine();
                      CharSequence _print = this.print(e, "__NEW_LINE");
                      _builder.append(_print, "");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                } else {
                  simple_statement _simple_7 = s.getSimple();
                  function_designator _function = _simple_7.getFunction();
                  boolean _notEquals_3 = (!Objects.equal(_function, null));
                  if (_notEquals_3) {
                    {
                      simple_statement _simple_8 = s.getSimple();
                      function_designator _function_1 = _simple_8.getFunction();
                      String _name_2 = _function_1.getName();
                      boolean _equals_1 = _name_2.equals("write");
                      if (_equals_1) {
                        _builder.append("; Call write");
                        _builder.newLine();
                        simple_statement _simple_9 = s.getSimple();
                        function_designator _function_2 = _simple_9.getFunction();
                        CharSequence _print_1 = this.print(e, b, _function_2);
                        _builder.append(_print_1, "");
                        _builder.newLineIfNotEmpty();
                      } else {
                        simple_statement _simple_10 = s.getSimple();
                        function_designator _function_3 = _simple_10.getFunction();
                        String _name_3 = _function_3.getName();
                        boolean _equals_2 = _name_3.equals("writeln");
                        if (_equals_2) {
                          _builder.append("; Call writeln");
                          _builder.newLine();
                          simple_statement _simple_11 = s.getSimple();
                          function_designator _function_4 = _simple_11.getFunction();
                          CharSequence _print_2 = this.print(e, b, _function_4);
                          _builder.append(_print_2, "");
                          _builder.newLineIfNotEmpty();
                          CharSequence _print_3 = this.print(e, "__NEW_LINE");
                          _builder.append(_print_3, "");
                          _builder.newLineIfNotEmpty();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
}
