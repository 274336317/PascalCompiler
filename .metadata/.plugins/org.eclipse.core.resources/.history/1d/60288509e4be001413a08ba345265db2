/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_declaration
import org.xtext.example.pascal.pascal.procedure_declaration
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	private Map<EObject, Set<Error>> errorList = new HashMap<EObject, Set<Error>>();
	private Map<EObject, Set<Variable>> variables = new HashMap<EObject, Set<Variable>>();
	
	def search(Set<Variable> variables, Variable key) {
		for (Variable v : variables) {
			if (v.equals(key))
				return v;
		} 
		return null;	
	}
	
	def clear(block block, VariableType varType) {
		if (!variables.containsKey(block)) {
			variables.put(block, new HashSet<Variable>());
		} else {
			var newSet = new HashSet<Variable>();
			for (Variable v : variables.get(block)) {
				if (v.varType != varType || v.isInherited) {
					newSet.add(v);
				}	
			} 
			variables.put(block, newSet);
		}
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		if (!errorList.containsKey(object)) {
			errorList.put(object, new HashSet<Error>());
		}
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		if (!errorList.containsKey(object)) {
			errorList.put(object, new HashSet<Error>());
		}
		errorList.get(object).remove(new Error(type));
	} 
	
	def inheritVariables(block block, String name, String variableType, VariableType type) {
		if (block.abstraction != null) {
			if (block.abstraction.procedures != null) {
				for (procedure_declaration declaration : block.abstraction.procedures) {
					if (declaration.block != null) {
						var subblock = declaration.block;
						if (!variables.containsKey(subblock)) {
							variables.put(subblock, new HashSet<Variable>());
						}
						variables.get(subblock).add(new Variable(name, variableType, true, type));
					}
				}
			}
			if (block.abstraction.functions != null) {
				for (function_declaration declaration : block.abstraction.functions) {
					if (declaration.block != null) {
						var subblock = declaration.block;
						if (!variables.containsKey(subblock)) {
							variables.put(subblock, new HashSet<Variable>());
						}
						variables.get(subblock).add(new Variable(name, variableType, true, type));
					}
				}
			}
		}
	}
	
	def addVariable(block block, String name, String type, VariableType varType, EObject errorSection, EStructuralFeature errorFeature) {
		var tempVariable = new Variable(name, type, false, varType);
		var searchVariable = search(variables.get(block), tempVariable);
		if (searchVariable != null && !searchVariable.isInherited) {
			if (varType == searchVariable.varType) { 
				insertError(errorSection, varType + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (searchVariable.varType == VariableType.VARIABLE) {
					insertError(errorSection, "Identifier is already being used by a variable.", ErrorType.REDECLARATION, errorFeature);
				} else if (searchVariable.varType == VariableType.CONSTANT) {
					insertError(errorSection, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, errorFeature);
				} else if (searchVariable.varType == VariableType.PARAMETER) {
					insertError(errorSection, "Identifier is already being used by a parameter.", ErrorType.REDECLARATION, errorFeature);
				}
			}
		} else { 
			removeError(section, ErrorType.REDECLARATION);
			variables.get(block).remove(searchVariable);
			variables.get(block).add(tempVariable);
			inheritVariables(block, name, null, VariableType.PARAMETER);
		}
	}
	
	@Check
	def checkAbstractionRedeclaration(block block) {
		clear(block, VariableType.PARAMETER);
		if (block.abstraction != null) {
			var abstraction = block.abstraction;
			if (abstraction.functions != null) {
				for (function_declaration func : abstraction.functions) {
					var heading = func.heading;
					if (heading.parameters != null) {
						if (heading.parameters.parameters != null) {
							for (formal_parameter_section section : heading.parameters.parameters) {
								if (section.variable != null) { 
									var variable = section.variable; 
									for (String name : variable.identifiers.names) {
										var tempVariable = new Variable(name, variable.type.toString(), false, VariableType.PARAMETER);
										var searchVariable = search(variables.get(block), tempVariable);
										if (searchVariable != null && !searchVariable.isInherited) {
											if (searchVariable.varType == VariableType.VARIABLE) {
												insertError(section, "Identifier is already being used by a variable.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											} else if (searchVariable.varType == VariableType.CONSTANT) {
												insertError(section, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											} else {
												insertError(section, "Parameter cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											}
										} else { 
											removeError(section, ErrorType.REDECLARATION);
											variables.get(block).remove(searchVariable);
											variables.get(block).add(tempVariable);
											inheritVariables(block, name, null, VariableType.PARAMETER);
										}
									}
								} else if (section.value != null) {
									var value = section.value;
									for (String name : value.identifiers.names) {
										var tempVariable = new Variable(name, value.type.toString(), false, VariableType.PARAMETER);
										var searchVariable = search(variables.get(block), tempVariable);
										if (searchVariable != null && !searchVariable.isInherited) {
											if (searchVariable.varType == VariableType.VARIABLE) {
												insertError(section, "Identifier is already being used by a variable.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											} else if (searchVariable.varType == VariableType.CONSTANT) {
												insertError(section, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											} else {
												insertError(section, "Parameter cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
											}
										} else { 
											removeError(section, ErrorType.REDECLARATION);
											variables.get(block).remove(searchVariable);
											variables.get(block).add(tempVariable);
											inheritVariables(block, name, null, VariableType.PARAMETER);
										}
									}
								}
							}
						}
					}
					heading.parameters.parameters;
				}
			}
			if (abstraction.procedures != null) {
				for (procedure_declaration procedure : abstraction.procedures) {
					
				}
			}
		}	
	}
	
	
	@Check
	def checkConstantRedeclaration(block block) {
		clear(block, VariableType.CONSTANT);
		if (block.constant != null) {
			for (constant_definition const : block.constant.consts) {
				var tempConst = new Variable(const.name, null, false, VariableType.CONSTANT);
				var searchConst = search(variables.get(block), tempConst); 
				if (searchConst != null && !searchConst.isInherited) { 
					if (searchConst.varType == VariableType.PARAMETER) {
						insertError(const, "Identifier is already being used by a parameter.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
					} else if (searchConst.varType == VariableType.VARIABLE) {
						insertError(const, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
					} else {
						insertError(const, "Constant cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
					}
				} else { 
					removeError(const, ErrorType.REDECLARATION);
					variables.get(block).remove(searchConst);
					variables.get(block).add(tempConst);
					inheritVariables(block, const.name, null, VariableType.CONSTANT);
				}
			}
		}
	} 
	
	@Check
	def checkVariableRedeclaration(block block) {		
		clear(block, VariableType.VARIABLE);
		if (block.variable != null) {
			for (variable_section section : block.variable.sections) {
				for (String name : section.identifiers.names) { 
					var tempVariable = new Variable(name, section.type.toString(), false, VariableType.VARIABLE);
					var searchVariable = search(variables.get(block), tempVariable);
					if (searchVariable != null && !searchVariable.isInherited) {
						if (searchVariable.varType == VariableType.PARAMETER) {
							insertError(section, "Identifier is already being used by a parameter.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
						} else if (searchVariable.varType == VariableType.CONSTANT) {
							insertError(section, "Identifier is already being used by a constant.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
						} else {
							insertError(section, "Variable cannot be redeclared.", ErrorType.REDECLARATION, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
						}
					} else { 
						removeError(section, ErrorType.REDECLARATION);
						variables.get(block).remove(searchVariable);
						variables.get(block).add(tempVariable);
						inheritVariables(block, name, null, VariableType.VARIABLE);
					}
				}
			}	
		}
	}
	
	def variableCheck(block block, variable variable) {
		var searchVariable = search(variables.get(block), new Variable(variable.name));
		if (searchVariable == null) {
			insertError(variable, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(variable, ErrorType.NOT_DECLARATION);
			if (searchVariable.varType == VariableType.CONSTANT) {
				insertError(variable, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
			} else {
				removeError(variable, ErrorType.CONSTANT_ASSIGNMENT);
			}
		}
	}
	
	def variableCheckExpression(block block, expression expr) {
		for (simple_expression s : expr.expressions) {
			for (term t : s.terms) {
				for (factor f : t.factors) {
					if (f.variable != null) {
						variableCheck(block, f.variable);
					}
				}
			}
		}
	}
	
	def variableCheckStatement(block block, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				var assignment = simple.assignment;
				var variable = assignment.variable;
				variableCheck(block, variable);
			} 
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound;
				variableCheckStatements(block, compound.sequence);
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					variableCheckStatement(block, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					variableCheckStatements(block, repetitive.repeatStmt.sequence);
				} else if (repetitive.forStmt != null) {
					variableCheck(block, repetitive.forStmt.assignment.variable);
					variableCheckStatement(block, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					variableCheckExpression(block, ifStmt.expression);
					variableCheckStatement(block, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						variableCheckStatement(block, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					variableCheckExpression(block, caseStmt.expression);
				}
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					variableCheck(block, v);
				}
				variableCheckStatement(block, withStmt.statement);
			}
		}
	}
	
	def variableCheckStatements(block block, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			variableCheckStatement(block, stmt);
		}
	} 
	
	@Check
	def checkVariableAssignment(block block) {
		variableCheckStatements(block, block.statement.sequence);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, err.feature);
			}
		}	 
	}
	
}
