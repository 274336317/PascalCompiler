/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	private Map<EObject, Set<Error>> errorList = new HashMap<EObject, Set<Error>>();
	private Map<block, Set<Variable>> variables = new HashMap<block, Set<Variable>>();
	private Map<block, Set<Procedure>> abstractions = new HashMap<block, Set<Procedure>>();
	private Map<block, Set<Type>> types = new HashMap<block, Set<Type>>();
	
	private Set<Procedure> standardAbstractions = new HashSet<Procedure>();
	private Set<Type> standardTypes = new HashSet<Type>();
	
	def getParameters(String... vars) {
		var variables = new HashSet<Variable>();
		var count = 0;
		for (String type : vars) {
			variables.add(new Variable("arg_" + count, type, false, ElementType.PARAMETER));
			count++;
		}
		var parameters = new HashSet<Variable>(variables);
		return parameters;	
	}
	
	def <T> replaceListElement(List<T> list, int index, T newElement) {
		var newList = new ArrayList<T>(list);
		newList.remove(index);
		newList.add(index, newElement);
		return newList;
	}
	
	def void addAbstraction(Set<Procedure> abstractions, block b, String name, String returnType, String... parameters) {
		var virtualParameters = parameters.toList;
		var isVirtual = false;
		for (var i = 0; i < virtualParameters.size; i++) {
			if (virtualParameters.get(i).equals("numeric")) {
				addAbstraction(abstractions, b, name, returnType, replaceListElement(virtualParameters, i, "integer"));
				addAbstraction(abstractions, b, name, returnType, replaceListElement(virtualParameters, i, "real"));
				isVirtual = true;
			} else if (virtualParameters.get(i).equals("?")) {
				
			}
		}
		if (!isVirtual) {
			if (returnType.equals("reflect")) { 
				if (parameters.length == 1) { 
					abstractions.add(new Function(name, true, getParameters(parameters), false, parameters.toList.get(0))); 
				} else {
					throw new RuntimeException("Invalid return type");
				}
			} else if (returnType.equals("void")) { 
					abstractions.add(new Procedure(name, false, getParameters(parameters), false)); 
			} else {
				abstractions.add(new Function(name, false, getParameters(parameters), false, returnType)); 
			}
		}
	}
	  
	def setStandardAbstractions(block b, Set<Procedure> it) {
		addAbstraction(b, "round", "integer", "real"); 
		addAbstraction(b, "chr", "char", "integer");
		addAbstraction(b, "abs", "reflect", "numeric");
		addAbstraction(b, "odd", "boolean", "integer");
		addAbstraction(b, "sqr", "reflect", "numeric");
		addAbstraction(b, "sqrt", "real", "numeric");
		addAbstraction(b, "sin", "real", "numeric");
		addAbstraction(b, "cos", "real", "numeric");
		addAbstraction(b, "arctan", "real", "numeric");
		addAbstraction(b, "ln", "real", "numeric");
		addAbstraction(b, "exp", "real", "numeric");
		addAbstraction(b, "succ", "...enumerated", "...enumerated");
		addAbstraction(b, "succ", "integer", "integer");
		addAbstraction(b, "pred", "...enumerated", "...enumerated");
		addAbstraction(b, "pred", "integer", "integer");
		addAbstraction(b, "new", "void", "^?");
		addAbstraction(b, "dispose", "void", "^?");
		addAbstraction(b, "strconcat", "void", "packed array of char", "packed array of char");
		addAbstraction(b, "strdelete", "void", "packed array of char", "integer", "integer");
		addAbstraction(b, "strinsert", "void", "packed array of char", "packed array of char", "integer");
		addAbstraction(b, "strlen", "integer", "packed array of char");
		addAbstraction(b, "strscan", "integer", "packed array of char", "packed array of char");
		addAbstraction(b, "strlen", "integer", "packed array of char");
		addAbstraction(b, "substr", "void", "packed array of char", "integer", "integer", "packed array of char");
		addAbstraction(b, "address", "integer", "^?");	
		addAbstraction(b, "length", "integer", "[]?");
		addAbstraction(b, "setlength", "void", "[]?", "integer");
		addAbstraction(b, "write", "void", "?");
		addAbstraction(b, "write", "void");
		addAbstraction(b, "writeln", "void", "?");
		addAbstraction(b, "writeln", "void");
		addAbstraction(b, "read", "void", "file", "?");
		addAbstraction(b, "readln", "void", "file", "?");
	}
	
	def getStandardAbstractions(block b) {
		setStandardAbstractions(b, standardAbstractions);
		return standardAbstractions;
	}
	
	def getStandardTypes() {
		if (standardTypes.isEmpty) {
			standardTypes.add(new Type("real", false));
			standardTypes.add(new Type("integer", false));
			standardTypes.add(new Type("shortint", false));
			standardTypes.add(new Type("longint", false));
			standardTypes.add(new Type("boolean", false));
			standardTypes.add(new Type("char", false)); 
		}	
		return standardTypes;
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		if (!errorList.containsKey(object)) {
			errorList.put(object, new HashSet<Error>());
		}
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		if (!errorList.containsKey(object)) {
			errorList.put(object, new HashSet<Error>());
		}
		errorList.get(object).remove(new Error(type));
		showError(object);
	} 
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		if (!container.containsKey(b)) {
			container.put(b, new HashSet<T>());
		} else {
			var newSet = new HashSet<T>();
			for (T t : container.get(b)) {
				if (t.type != type || t.isInherited) {
					newSet.add(t);
				}	 
			} 
			container.put(b, newSet);
		}
		if (container == abstractions) {
			abstractions.get(b).addAll(getStandardAbstractions(b));
		} else if (container == types) {
			types.get(b).addAll(getStandardTypes());
		}
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getType(type t) {  
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				return "...enumerated";
			} else if (simple.name != null) {
				return simple.name;
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				syntetizedType += "array of " + getType(unpacked.array.type);
			} else if (unpacked.dynamic != null) {
				syntetizedType += "array of " + getType(unpacked.dynamic.type);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(unpacked.set.type);
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(unpacked.file.type);
			}
			return syntetizedType;
		} else if (t.pointer != null) {
			return "^" + getType(t.pointer.type);
		}
		return null;
	}
	
	def String getType(parameter_type type) {
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				return "packed array of " + array.packed.name;
			} else if (array.unpacked != null) {
				return "array of " + getType(array.unpacked.type);
			}
		} else if (type.name != null) {
			return type.name;
		}
		return null;	
	}
	
	def String getType(block b, variable v) {
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			return variableFound.getVarType();
		} 
		return null;
	} 
	
	def String getType(block b, function_designator f) {
		var function = getAbstraction(b, f);
		var abstractionFound = search(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			return functionFound.returnType;
		}
		return null;
	}
	
	def String getType(block b, factor f) {
		if (f.variable != null) {
			return getType(b, f.variable);
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				return "integer";
			} else if (number.real != null) {
				return "real";
			}
		} else if (f.string != null) {
			return "packed array of char";
		} else if (f.set != null) {
			return getType(b, f.set.expressions); 
		} else if (f.nil) {
			return "nil";
		} else if (f.boolean != null || f.not != null) {
			return "boolean";
		} else if (f.function != null) {
			return getType(b, f.function);
		} else if (f.expression != null) {
			return getType(b, f.expression);
		}
		return null;
	}
	
	def String getType(block b, term t) {
		var greatestType = "";
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		return greatestType;
	}
	
	def String getType(block b, simple_expression expr) {
		var greatestType = "";
		for (term t : expr.terms) {
			var type = getType(b, t);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		return greatestType;
	}
	
	def String getType(block b, expression expr) {
		var greatestType = "";
		for (simple_expression e : expr.expressions) {
			var type = getType(b, e);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		return greatestType;
	}
	
	def String getType(block b, expression_list expr) {
		var greatestType = "";
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		return greatestType;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		if (!container.containsKey(subblock)) {
			container.put(subblock, new HashSet<T>());
		} 
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, function.heading.returnType, false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var elementFound = search(container.get(b), element);
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			addElement(b, new Function(name, false, parameters, forward, returnType), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, false, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, const.const.toString(), false, ElementType.CONSTANT), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) {  
					addElement(b, new Variable(name, getType(section.type), false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def checkVariable(block b, variable v, boolean isAssignment) { 
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						insertError(object, "Incompatible types of arguments.", ErrorType.NOT_DECLARATION, feature);
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			for (term t : s.terms) {
				for (factor f : t.factors) {
					if (f.variable != null) {
						checkVariable(b, f.variable, false);
					} if (f.function != null) {	
						checkAbstractionCall(b, f.function, true);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				checkVariable(b, simple.assignment.variable, true);
				var variableType = getType(b, simple.assignment.variable);
				var expressionType = getType(b, simple.assignment.expression);
				if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
					 insertError(simple.assignment, "Cannot convert type " + expressionType.toLowerCase + " to " + variableType.toLowerCase + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
				} else {
					removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) == null) {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				} else {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
