/*
 * generated by Xtext
 */
package org.xtext.example.pascal.generator

import java.util.HashMap
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.validation.ComposedType
import org.xtext.example.pascal.validation.ComposedTypeKind
import org.xtext.example.pascal.validation.ElementType
import org.xtext.example.pascal.validation.PascalValidator
import org.xtext.example.pascal.validation.Type
import org.xtext.example.pascal.validation.TypeInferer
import org.xtext.example.pascal.validation.Variable

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class PascalGenerator implements IGenerator {
	
	private HashMap<String, String> stringTable = new HashMap<String, String>();
	private int labelCount;
	private int conditionalLabelCount;
	private int caseLabelCount;
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for (e: resource.allContents.toIterable.filter(program)) {
			labelCount = 0;
			conditionalLabelCount = 0;
			caseLabelCount = 0;
			fsa.generateFile(e.heading.name + ".asm", e.compile);
		}
	}

	def createStringTable(program e) {
		stringTable.clear();
		for (s : e.eAllContents.toIterable.filter(factor)) {
			if (s.string != null) {
				if (!stringTable.containsKey(s.string)) {
					stringTable.put(s.string, "__STRING_" + stringTable.size());
				}
			}
		}
	}
	
	def getVariables(program e, block b) {
		var artefacts = PascalValidator.artefacts.get(e.heading.name);
		var map = artefacts.get("variables") as Map<block, Set<Variable>>;
		//memoryCount.put(b, memoryInit);
		createStringTable(e);
		return map.get(b);
	}
	
	def getNumberOfBytes(Type t) {
		var type = t.realType.toLowerCase;
		if (type.equals("boolean") || type.equals("shortint")) {
			return 1;
		} else if (type.equals("char")) {
			return 2;
		} else if (type.equals("integer")) {
			return 4;
		} else if (type.equals("longint") || type.equals("real")) {
			return 8;
		} 
		return 4;
	}
	
	def getNumberOfBytes(Variable v) {
		return getNumberOfBytes(v.varType);	
	}
	
	def getValue(Variable v) {
		if (v.value instanceof String) {
			return "'" + v.value.toString.replaceAll("'", "\"") + "'";
		} else if (v.value instanceof Boolean) {
			if (v.value.equals(true)) {
				return 1;
			} else {
				return 0;
			}
		}
		return v.value;
	}
	
	def Type getType(program e, expression expr) {
		var artefacts = PascalValidator.artefacts.get(e.heading.name);
		var map = artefacts.get("calculatedTypes") as Map<EObject, Type>;
		return map.get(expr); 
	}
	
	def Variable searchVariable(program e, block b, variable v) {
		var artefacts = PascalValidator.artefacts.get(e.heading.name);
		var map = artefacts.get("variables") as Map<block, Set<Variable>>;
		var variables = map.get(b);
		for (Variable myVar : variables) {
			if (myVar.name.toLowerCase.equals(v.name.toLowerCase)) {
				return myVar;
			}	
		}
		return null;
	}
	
	def Type getType(program e, block b, variable v) {
		var variableFound = searchVariable(e, b, v);
		if (variableFound != null) {
			return variableFound.varType;
		}
		return new Type("nil");
	}
	
	def boolean isConstant(program e, block b, variable v) {
		var variableFound = searchVariable(e, b, v);
		if (variableFound != null) {
			return variableFound.type == ElementType.CONSTANT;
		}
		return false;
	}
	
	def printString(program e) '''
		; Print string
		_print_string:
			push eax
			push ebx 
			sub esp, ebx
			mov [esp], dword eax
			call _printf
			add esp, ebx
			pop eax 
			pop ebx
			ret ;return
			
	'''
	
	def printInteger(program e) '''
		; Print integer
		_print_integer:
			push eax
			sub esp, 4
			mov [esp], eax
			sub esp, 4
			lea eax, [__PRINTF_I]
			mov [esp], eax
			call _printf
			add esp, 4
			add esp, 4
			pop eax
			ret ;return 
			
	'''
	
	def printBoolean(program e) '''
		; Print boolean
		_print_boolean:
			jnz .print_boolean_true
			push eax
			push ebx 
			«e.print("__BOOLEAN_FALSE")»
			pop eax
			pop ebx
			ret ;return
			.print_boolean_true:
			push eax
			push ebx 
			«e.print("__BOOLEAN_TRUE")»
			pop eax
			pop ebx
			ret ;return
			
	'''
	
	def printFloat(program e) '''
		; Print float
		_print_float:
			push eax 
			sub esp, 8
			mov [esp], eax
			sub esp, 4
			lea eax, [__PRINTF_F]
			mov [esp], eax
			call _printf
			add esp, 12
			pop eax 
			ret ;return 
			
	'''
	
	def compilePredefinedProcedures(program e) '''
		«e.printString»
		«e.printInteger»
		«e.printBoolean»
		«e.printFloat»
	'''
	
	def compile(program e) '''
		; Program «e.heading.name»
		global _main
		
		extern _printf
		extern _scanf 
		
		«e.compile(e.block, e.getVariables(e.block))» 
		
		; Code
		section .text
		
		«e.compilePredefinedProcedures»
		_main:
			«e.compileSequence(e.block, e.block.statement.sequence)» 
			ret	; Exit program
	'''

	def compile(program e, block b, Set<Variable> variables) ''' 
		; Loading global constants and strings
		section .data
			__NEW_LINE db 10, 0
			__NEW_LINE_SIZE equ $-__NEW_LINE
			__PRINTF_S db '%s', 0
			__PRINTF_I db '%d', 0
			__PRINTF_F db '%f', 0
			__BOOLEAN_TRUE db 'true', 0
			__BOOLEAN_TRUE_SIZE equ $-__BOOLEAN_TRUE
			__BOOLEAN_FALSE db 'false', 0
			__BOOLEAN_FALSE_SIZE equ $-__BOOLEAN_FALSE
			«FOR s : stringTable.keySet» 
				«e.compileGlobalConstant(new Variable(stringTable.get(s), new ComposedType(new Type("char"), 
					ComposedTypeKind.ARRAY), false, ElementType.CONSTANT, s), b)»
			«ENDFOR»
			«FOR v : variables»
				«e.compileGlobalConstant(v, b)»
			«ENDFOR»
		
		; Loading global variables
		section .bss
			«FOR v : variables»
				«e.compileGlobalVariables(v, b)»
			«ENDFOR» 
	'''
	 
	def compileGlobalConstant(program e, Variable v, block b) '''
		«IF v.type == ElementType.CONSTANT»
			«IF v.varType.realType.toLowerCase.equals("array of char")» 
				«v.name» db «getValue(v)», 0
				«v.name»_SIZE equ $-«v.name»
			«ELSE»
				«v.name» equ «getValue(v)»
			«ENDIF»
		«ENDIF»
	'''
	
	def compileGlobalVariables(program e, Variable v, block b) '''
		«IF v.type == ElementType.VARIABLE»
			«v.name» RESB «getNumberOfBytes(v)»
		«ENDIF»
	'''
	
	def computeFunction(program e, block b, function_designator function) '''
	'''
	
	def CharSequence computeFactor(program e, block b, factor f) '''
		«IF f.string != null»
			lea eax, [«stringTable.get(f.string)»]
			mov ebx, «stringTable.get(f.string)»_SIZE
		«ELSEIF f.number != null»
			«IF f.number.number.integer != null»
				mov eax, «f.number.number.integer»
			«ELSE»
			«ENDIF»
		«ELSEIF f.boolean != null»
			«IF f.boolean.toLowerCase.equals("true")»
				mov eax, 1
			«ELSE»
				mov eax, 0
			«ENDIF»
		«ELSEIF f.variable != null»
			«IF e.isConstant(b, f.variable)»
				mov eax, «f.variable.name»
			«ELSE»
				mov eax, [«f.variable.name»]
			«ENDIF»
			«IF e.getType(b, f.variable).realType.toLowerCase.equals("array of char")»
				mov ebx, «f.variable.name»_SIZE
			«ENDIF»
		«ELSEIF f.function != null»
			«e.computeFunction(b, f.function)»
		«ELSEIF f.expression != null»
			«e.computeExpression(b, f.expression)»
		«ELSEIF f.not != null»
			«e.computeFactor(b, f.not)»
			xor eax, 1 ; Logical not
		«ENDIF»
	'''
	
	def computeTerm(program e, block b, term t) '''
		push ecx
		«e.computeFactor(b, t.factors.get(0))»
		«IF t.operators != null»
			«var int index = 1»
			«FOR operator : t.operators»
				mov ecx, eax
				«e.computeFactor(b, t.factors.get(index++))»
				«IF operator.toLowerCase.equals("and")»
					and ecx, eax ; And
				«ELSEIF operator.toLowerCase.equals("mod")»
					mov edx, eax ; Module
					mov eax, ecx
					mov ecx, edx
					cdq
					idiv ecx
					mov ecx, edx
				«ELSEIF operator.toLowerCase.equals("div") || operator.equals("/")»
					mov edx, eax ; Divide
					mov eax, ecx
					mov ecx, edx
					cdq
					idiv ecx
					mov ecx, eax
				«ELSEIF operator.equals("*")»
					mul ecx ; Multiply
					mov ecx, eax
				«ENDIF»
				mov eax, ecx
			«ENDFOR»
		«ENDIF»
		pop ecx
	'''
	
	def computeSimpleExpression(program e, block b, simple_expression exp) '''
		push ecx
		«e.computeTerm(b, exp.terms.get(0) as term)»
		«IF exp.prefixOperator != null»
			«IF exp.prefixOperator.equals("-")»
				neg aex
			«ENDIF» 
		«ENDIF»
		«IF exp.operators != null»
			«var int index = 1»
			«FOR operator : exp.operators»
				mov ecx, eax
				«IF exp.terms.get(index) instanceof term»
					«e.computeTerm(b, exp.terms.get(index++) as term)»
				«ELSE»
					mov eax, «(exp.terms.get(index++) as any_number).integer»
				«ENDIF»
				«IF operator.equals("or")»
					or ecx, eax ; Logical or
				«ELSEIF operator.equals("+")»
					add ecx, eax ; Sum
				«ELSEIF operator.equals("-")»
					sub ecx, eax ; Sub
				«ENDIF»
				mov eax, ecx
			«ENDFOR»
		«ENDIF»
		pop ecx
	'''
	
	def computeExpression(program e, block b, expression exp) '''
		push ecx
		«e.computeSimpleExpression(b, exp.expressions.get(0))»
		«IF exp.operators != null»
			«var int index = 1»
			«FOR operator : exp.operators»
				mov ecx, eax
				«e.computeSimpleExpression(b, exp.expressions.get(index++))»
				cmp ecx, eax
				«IF operator.equals("=")»
					je .set_to_true«labelCount» ; Equal
					jmp .set_to_false«labelCount»
				«ELSEIF operator.equals(">")»
					jg .set_to_true«labelCount» ; Greater
					jmp .set_to_false«labelCount»
				«ELSEIF operator.equals(">=")»
					jge .set_to_true«labelCount» ; Greater or equal
					jmp .set_to_false«labelCount»
				«ELSEIF operator.equals("<")»
					jl .set_to_true«labelCount» ; Lesser
					jmp .set_to_false«labelCount»
				«ELSEIF operator.equals("<=")»
					jle .set_to_true«labelCount» ; Lesser of equal
					jmp .set_to_false«labelCount»
				«ELSEIF operator.equals("<>")»
					jne .set_to_true«labelCount» ; Different
					jmp .set_to_false«labelCount»
				«ENDIF»
				.set_to_true«labelCount»:
					mov ecx, 1
					jmp .out«labelCount»
				.set_to_false«labelCount»:
					mov ecx, 0
				.out«labelCount++»:
					mov eax, ecx
			«ENDFOR»
		«ENDIF»
		pop ecx
	'''
	
	def print(program e, block b, function_designator function) '''
		«IF function.expressions != null»
			«e.computeExpression(b, function.expressions.expressions.get(0))»
			«IF TypeInferer.getTypeWeight(e.getType(function.expressions.expressions.get(0))) == 4»
				call _print_float
			«ELSEIF TypeInferer.getTypeWeight(e.getType(function.expressions.expressions.get(0))) >= 0»
				call _print_integer
			«ELSEIF e.getType(function.expressions.expressions.get(0)).realType.toLowerCase.equals("boolean")»
				and eax, 1 ; Setting zero flag
				call _print_boolean
			«ELSE»
				call _print_string
			«ENDIF»
		«ENDIF»
	'''
	
	def print(program e, String s) '''
		lea eax, [«s»]
		mov ebx, «s»_SIZE
		call _print_string
	'''
	
	def CharSequence compileSequence(program e, block b, statement_sequence sequence) '''
		«FOR stmt : sequence.statements»
			«e.compileStatement(b, stmt)»
		«ENDFOR»
	'''
	
	def CharSequence compileStatement(program e, block b, statement s) '''
		«IF s.simple != null»
			«IF s.simple.assignment != null»
				; Assigning «s.simple.assignment.variable.name»
				«e.computeExpression(b, s.simple.assignment.expression)»
				mov [«s.simple.assignment.variable.name»], eax
			«ELSEIF s.simple.function_noargs != null»
				«IF s.simple.function_noargs.equals("writeln")»
					; Call writeln
					«e.print("__NEW_LINE")»
				«ENDIF»
			«ELSEIF s.simple.function != null»
				«IF s.simple.function.name.equals("write")»
					; Call write
					«e.print(b, s.simple.function)»
				«ELSEIF s.simple.function.name.equals("writeln")»
					; Call writeln
					«e.print(b, s.simple.function)»
					«e.print("__NEW_LINE")»
				«ENDIF»
			«ENDIF»
		«ELSEIF s.structured != null»
			«IF s.structured.compound != null»
				«e.compileSequence(b, s.structured.compound.sequence)»
			«ELSEIF s.structured.repetitive != null»
			
			«ELSEIF s.structured.conditional != null»
				«IF s.structured.conditional.ifStmt != null»
					; If statement
					«var ifStmt = s.structured.conditional.ifStmt»
					«e.computeExpression(b, ifStmt.expression)»
					and eax, 1 ; Setting zero flag
					«var int label = conditionalLabelCount++»
					jz .else_body«label»
					.if_body«label»:
						«e.compileStatement(b, ifStmt.ifStatement)»
						jmp .conditional_out«label»
					.else_body«label»:
						«IF ifStmt.elseStatement != null»
							«e.compileStatement(b, ifStmt.elseStatement)»
						«ENDIF»
					.conditional_out«label»:
				«ELSEIF s.structured.conditional.caseStmt != null»
					; Case statement
					«var caseStmt = s.structured.conditional.caseStmt»
					«e.computeExpression(b, caseStmt.expression)»
					«FOR c : caseStmt.cases»
						; Case limb
						«var int label = caseLabelCount++»
						«FOR constant : c.cases.constants»
							
						«ENDFOR»
						jmp .case_limb_out«label»
						.case_limb_body«label»
						.case_limb_out«label»
					«ENDFOR»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	'''
	
}
