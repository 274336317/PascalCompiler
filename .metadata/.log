!SESSION 2015-03-07 15:58:43.056 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.dsl.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.dsl.product

This is a continuation of log file C:\Users\dell\workspace\Pascal\.metadata\.bak_1.log
Created Time: 2015-03-08 03:18:43.892

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.898
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 91 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.900
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.910
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 89 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.911
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.922
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 87 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.924
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:43.934
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.pascal.type

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.pascal.type' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.946
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type_definition.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 91 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.948
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.958
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type_definition.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 89 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.960
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.969
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/type_definition.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 87 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.971
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\type_definition.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:43.981
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.pascal.type_definition

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.pascal.type_definition' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:43.993
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 91 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:43.994
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:44.004
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 89 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:44.006
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:44.019
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 87 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:44.020
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.034
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.pascal.variable

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.pascal.variable' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:44.047
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable_section.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 91 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:44.048
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:44.059
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable_section.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 89 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:44.060
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:44.073
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/variable_section.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 87 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:44.075
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\variable_section.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.089
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.pascal.variable_section

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.pascal.variable_section' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getContents(BatchLinkableResource.java:134)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareBatchTypeResolver.getEntryPoints(LogicalContainerAwareBatchTypeResolver.java:27)
	at org.eclipse.xtend.core.typesystem.TypeDeclarationAwareBatchTypeResolver.getEntryPoints(TypeDeclarationAwareBatchTypeResolver.java:30)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver.getTypeResolver(DefaultBatchTypeResolver.java:57)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:48)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$1.get(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:46)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.262
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.PascalPackage


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.276
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.abstraction_declaration


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.287
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.abstraction_heading


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.297
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.any_number


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.308
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.block


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.317
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.case_limb


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.327
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.constant


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.337
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.constant_definition


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.348
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.expression_list


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.361
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.factor


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.371
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.formal_parameter_section


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.382
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.function_designator


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.393
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.number


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.430
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.parameter_type


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.440
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.program


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.451
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.simple_expression


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.461
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.statement


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.472
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.statement_sequence


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.483
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.term


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.494
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.type


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.504
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.type_definition


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.521
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.variable


!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:44.536
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.pascal.variable_section


!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:46.111
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/statement_part.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 104 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:46.113
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:46.127
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/statement_part.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 102 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:46.129
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 03:18:46.143
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/pascal/statement_part.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 100 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 03:18:46.145
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\pascal\statement_part.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 03:18:46.159
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.pascal.statement_part

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.pascal.statement_part' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:144)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:54)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:41)
	at org.eclipse.xtext.scoping.impl.AbstractScope.getSingleElement(AbstractScope.java:105)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.xtype.impl.XImportDeclarationImpl.getImportedType(XImportDeclarationImpl.java:253)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getImportScope(XtendImportedNamespaceScopeProvider.java:261)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.access$1(XtendImportedNamespaceScopeProvider.java:231)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:112)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider$1.get(XtendImportedNamespaceScopeProvider.java:1)
	at org.eclipse.xtext.util.OnChangeEvictingCache.get(OnChangeEvictingCache.java:75)
	at org.eclipse.xtend.core.scoping.XtendImportedNamespaceScopeProvider.getScope(XtendImportedNamespaceScopeProvider.java:106)
	at org.eclipse.xtext.xbase.scoping.batch.TypeScopes.createTypeScope(TypeScopes.java:59)
	at org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider.getScope(XbaseBatchScopeProvider.java:100)
	at org.eclipse.xtext.xbase.annotations.typesystem.XbaseWithAnnotationsBatchScopeProvider.getScope(XbaseWithAnnotationsBatchScopeProvider.java:52)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getScope(DefaultLinkingService.java:59)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:118)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.getType(LightweightTypeReferenceFactory.java:241)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:173)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.doVisitParameterizedTypeReference(LightweightTypeReferenceFactory.java:1)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImplCustom.accept(JvmParameterizedTypeReferenceImplCustom.java:53)
	at org.eclipse.xtext.common.types.util.AbstractTypeReferenceVisitor.visit(AbstractTypeReferenceVisitor.java:33)
	at org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory.toLightweightReference(LightweightTypeReferenceFactory.java:83)
	at org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner.toLightweightTypeReference(StandardTypeReferenceOwner.java:109)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:520)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver._doPrepare(XtendReentrantTypeResolver.java:648)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:445)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepareMembers(LogicalContainerAwareReentrantTypeResolver.java:482)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver._doPrepare(LogicalContainerAwareReentrantTypeResolver.java:453)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.doPrepare(LogicalContainerAwareReentrantTypeResolver.java:441)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.prepare(LogicalContainerAwareReentrantTypeResolver.java:391)
	at org.eclipse.xtext.xbase.typesystem.internal.LogicalContainerAwareReentrantTypeResolver.computeTypes(LogicalContainerAwareReentrantTypeResolver.java:674)
	at org.eclipse.xtend.core.typesystem.XtendReentrantTypeResolver.computeTypes(XtendReentrantTypeResolver.java:346)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.resolve(DefaultReentrantTypeResolver.java:152)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultReentrantTypeResolver.reentrantResolve(DefaultReentrantTypeResolver.java:132)
	at org.eclipse.xtext.xbase.typesystem.internal.DefaultBatchTypeResolver$1.reentrantResolve(DefaultBatchTypeResolver.java:96)
	at org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver.reentrantResolve(CompoundReentrantTypeResolver.java:77)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$LazyResolvedTypes.resolveTypes(CachingBatchTypeResolver.java:79)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:56)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver$2.process(CachingBatchTypeResolver.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.util.OnChangeEvictingCache.execWithoutCacheClear(OnChangeEvictingCache.java:127)
	at org.eclipse.xtext.xbase.typesystem.internal.CachingBatchTypeResolver.doResolveTypes(CachingBatchTypeResolver.java:52)
	at org.eclipse.xtext.xbase.typesystem.internal.AbstractBatchTypeResolver.resolveTypes(AbstractBatchTypeResolver.java:55)
	at org.eclipse.xtext.xbase.resource.BatchLinkingService.resolveBatched(BatchLinkingService.java:64)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.resolveLazyCrossReferences(BatchLinkableResource.java:151)
	at org.eclipse.xtext.EcoreUtil2.resolveLazyCrossReferences(EcoreUtil2.java:513)
	at org.eclipse.xtext.builder.clustering.ClusteringBuilderState.doUpdate(ClusteringBuilderState.java:219)
	at org.eclipse.xtext.builder.builderState.AbstractBuilderState.update(AbstractBuilderState.java:112)
	at org.eclipse.xtext.builder.impl.XtextBuilder.doBuild(XtextBuilder.java:187)
	at org.eclipse.xtext.builder.impl.XtextBuilder.incrementalBuild(XtextBuilder.java:167)
	at org.eclipse.xtext.builder.impl.XtextBuilder.build(XtextBuilder.java:95)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:25.461
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12595, length: 1, timestamp: 5561
text:><



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:25.563
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12608, length: 1, timestamp: 5562
text:><



!ENTRY org.eclipse.core.jobs 4 2 2015-03-08 09:54:25.647
!MESSAGE An internal error occurred during: "XtextReconcilerJob".
!STACK 0
java.lang.IllegalStateException
	at com.google.common.base.Preconditions.checkState(Preconditions.java:134)
	at com.google.common.collect.AbstractIterator.hasNext(AbstractIterator.java:130)
	at com.google.common.collect.AbstractIterator.next(AbstractIterator.java:153)
	at org.eclipse.xtext.ui.editor.model.PartitionTokenScanner.nextToken(PartitionTokenScanner.java:97)
	at org.eclipse.xtext.ui.editor.model.DocumentPartitioner.initialize(DocumentPartitioner.java:226)
	at org.eclipse.xtext.ui.editor.model.DocumentPartitioner.checkInitialization(DocumentPartitioner.java:198)
	at org.eclipse.xtext.ui.editor.model.DocumentPartitioner.computePartitioning(DocumentPartitioner.java:731)
	at org.eclipse.jface.text.AbstractDocument.computePartitioning(AbstractDocument.java:1430)
	at org.eclipse.jface.text.TextUtilities.computePartitioning(TextUtilities.java:431)
	at org.eclipse.xtext.ui.editor.reconciler.XtextSpellingReconcileStrategy.computePartitioning(XtextSpellingReconcileStrategy.java:85)
	at org.eclipse.xtext.ui.editor.reconciler.XtextSpellingReconcileStrategy.reconcile(XtextSpellingReconcileStrategy.java:77)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:67)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:25.738
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			}
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12665, length: 1, timestamp: 5563
text:><



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:33.511
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			} 
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12669, length: 0, timestamp: 5564
text:> <



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:40.841
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(l, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			} 
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12444, length: 4, timestamp: 5565
text:>l<



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:41.044
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(li, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			} 
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12445, length: 0, timestamp: 5566
text:>i<



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:41.181
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(lim, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			} 
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12446, length: 0, timestamp: 5567
text:>m<



!ENTRY org.apache.log4j 4 0 2015-03-08 09:54:41.306
!MESSAGE org.eclipse.xtext.ui.editor.model.DocumentPartitioner  - Detected unexpected state in document partitioner. Please file a bug with the following information attached:
Document content after the event was applied:
>>>/*
 * generated by Xtext
 */
package org.xtext.example.pascal.validation

import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.example.pascal.pascal.PascalPackage
import org.xtext.example.pascal.pascal.abstraction_declaration
import org.xtext.example.pascal.pascal.abstraction_heading
import org.xtext.example.pascal.pascal.any_number
import org.xtext.example.pascal.pascal.block
import org.xtext.example.pascal.pascal.case_label_list
import org.xtext.example.pascal.pascal.case_limb
import org.xtext.example.pascal.pascal.constant
import org.xtext.example.pascal.pascal.constant_definition
import org.xtext.example.pascal.pascal.expression
import org.xtext.example.pascal.pascal.expression_list
import org.xtext.example.pascal.pascal.factor
import org.xtext.example.pascal.pascal.formal_parameter_section
import org.xtext.example.pascal.pascal.function_designator
import org.xtext.example.pascal.pascal.number
import org.xtext.example.pascal.pascal.parameter_type
import org.xtext.example.pascal.pascal.program
import org.xtext.example.pascal.pascal.simple_expression
import org.xtext.example.pascal.pascal.statement
import org.xtext.example.pascal.pascal.statement_sequence
import org.xtext.example.pascal.pascal.term
import org.xtext.example.pascal.pascal.type
import org.xtext.example.pascal.pascal.type_definition
import org.xtext.example.pascal.pascal.variable
import org.xtext.example.pascal.pascal.variable_section

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PascalValidator extends AbstractPascalValidator {
	
	public static final Map<String, Map<String, Object>> artefacts = new HashMap<String, Map<String, Object>>();

	private final Map<EObject, Set<Error>> errorList = new AdaptativeHashMap<EObject, Error>();
	private final Map<block, Set<Variable>> variables = new AdaptativeHashMap<block, Variable>();
	private final Map<block, Set<Procedure>> abstractions = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	private final Map<block, Set<Type>> types = new AdaptativeHashMap<block, Type>(APIProvider.types);
	private final Map<EObject, Type> calculatedTypes = new HashMap<EObject, Type>();
	 
	@Check
	def fillArtefacts(program p) {
		var name = p.heading.name;
		if (!artefacts.containsKey(name)) {
			artefacts.put(name, new HashMap<String, Object>());
			artefacts.get(name).put("variables", variables);
			artefacts.get(name).put("abstractions", abstractions);
			artefacts.get(name).put("types", types);
			artefacts.get(name).put("calculatedTypes", calculatedTypes);
		}	
	}
	
	def <T extends Element> search(Set<T> elements, T key) {
		for (T t : elements) {
			if (t.equals(key))
				return t;
		} 
		return null;	
	}
	
	def searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure t : elements) {
			if (t.equals(key))
				return t;
			if (t.equalsWithTypeCoersion(key))
				optimal = t;
		}  
		return optimal;
	}
	 
	def Type searchByName(Set<Type> types, Type key) {
		for (Type t : types) {
			if (t.name.toLowerCase.equals(key.name.toLowerCase)) {
				return t;
			} 
		}	
		return null;
	}
	
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		errorList.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		errorList.get(object).remove(new Error(type));
		showError(object);
	}  
	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T t : container.get(b)) {
			if (t.type != type || t.isInherited) {
				newSet.add(t);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new HashSet<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression e : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, e), false, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(types.get(b), new Type(type));
		if (foundType != null) {
			return foundType.realType;
		}	
		return type;
	}
	
	def Type getType(block b, String type) {
		if (type == null) return null;
		if (type.length > 1 && type.substring(0, 1).equals("^")) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		} else if (type.length > 9 && type.substring(0, 9).equals("array of ")) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	def Type getType(block b, type t) {  
		var Type type = new Type("nil");
		if (t.simple != null) {
			var simple = t.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				type = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(types.get(b), new Type(simple.name)) == null) {
					insertError(t, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(t, ErrorType.UNDEFINED_TYPE);
				} 
				type = getType(b, simple.name);
			} 
		} else if (t.structured != null) {
			var syntetizedType = "";
			var structured = t.structured;
			if (structured.packed) {
				syntetizedType += "packed ";
			}
			var unpacked = structured.type;
			if (unpacked.array != null) {
				type = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.dynamic != null) {
				type = new ComposedType(getType(b, unpacked.dynamic.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				syntetizedType += "record";
			} else if (unpacked.set != null) {
				syntetizedType += "set of " + getType(b, unpacked.set.type).realType;
			} else if (unpacked.file != null) {
				syntetizedType += "file of " + getType(b, unpacked.file.type).realType;
			}
			type = new Type(syntetizedType);
		} else if (t.pointer != null) {
			type = new ComposedType(getType(b, t.pointer.type), ComposedTypeKind.POINTER);
		} 
		return type;
	}
	
	def Type getType(block b, parameter_type type) {
		var t = new Type("nil");
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				t = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				t = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(types.get(b), new Type(type.name)) == null) {
				insertError(type, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			t = getType(b, type.name);
		}	
		return t;
	}
	
	def Type getType(block b, constant const) {
		var type = new Type("nil");
		if (const.name != null) {
			var varFound = search(variables.get(b), new Variable(const.name));
			if (varFound != null) {
				type = varFound.varType;
			} 
		} else if (const.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (const.boolLiteral != null) {
			type = new Type("boolean");
		} else if (const.nil != null) {
			type = new Type("nil");
		} else if (const.number != null) {
			if (const.number.number.integer != null) {
				type = new Type("integer");
			} else if (const.number.number.real != null) {
				type = new Type("real");
			} 
		}
		return type;
	}
	
	def Type getType(block b, variable v) {
		var type = new Type("nil");
		var variableFound = search(variables.get(b), new Variable(v.name)); 
		if (variableFound != null) {
			type = variableFound.varType;
		} 
		return type;
	} 
	
	def Type getType(block b, function_designator f) {
		var type = new Type("nil");
		var function = getAbstraction(b, f);
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			type = functionFound.returnType;  
		}
		return type;
	}
	
	def Type getType(block b, factor f) {
		var type = new Type("nil");
		if (f.variable != null) {
			var variableFound = search(variables.get(b), new Variable(f.variable.name));
			if (variableFound != null) {
				type = variableFound.varType;		
			}
		} else if (f.number != null) {
			var number = f.number.number;
			if (number.integer != null) {
				type = new Type("integer");
			} else if (number.real != null) {
				type = new Type("real");
			}
		} else if (f.string != null) {
			type = new ComposedType(new Type("char"), ComposedTypeKind.ARRAY);
		} else if (f.set != null) {
			type = getType(b, f.set.expressions, true); 
		} else if (f.nil) {
			type = new Type("nil");
		} else if (f.boolean != null || f.not != null) {
			type = new Type("boolean");
		} else if (f.function != null) {
			type = getType(b, f.function);
		} else if (f.expression != null) {
			type = getType(b, f.expression);
		}
		calculatedTypes.put(f, type);
		return type;
	}
	
	def Type getType(block b, term t) {
		var Type greatestType = null; 
		for (factor f : t.factors) {
			var type = getType(b, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(t, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, simple_expression expr) {
		var Type greatestType = null;
		for (EObject obj : expr.terms) {
			if (obj instanceof term) {
				var t = obj as term;
				var type = getType(b, t);
				greatestType = TypeInferer.greater(type, greatestType);
			} else {
				var n = obj as any_number;
				if (n.integer != null) {
					greatestType = TypeInferer.greater(new Type("integer"), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type("real"), greatestType);
				}
			}
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, expression expr) {
		var t = new Type("nil");
		if (expr.operators != null && !expr.operators.empty) {
			t = new Type("boolean");
		} else {
			var Type greatestType = null;
			for (simple_expression e : expr.expressions) {
				var type = getType(b, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			t = greatestType;
		}
		calculatedTypes.put(expr, t);
		return t;
	}
	
	def Type getType(block b, expression_list expr, boolean isCohese) {
		var Type greatestType = null;
		for (expression e : expr.expressions) {
			var type = getType(b, e);
			if (isCohese) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expr, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
				} else {
					removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		calculatedTypes.put(expr, greatestType);
		return greatestType;
	}
	
	def Type getType(block b, case_limb limb) {
		var Type greatestType = null;
		for (constant c : limb.cases.constants) {
			var type = getType(b, c);
			if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
				TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
				insertError(limb, "Cannot convert " + type +  " to " + greatestType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
			} else {
				removeError(expr, ErrorType.TYPE_CONVERSION_ERROR);
			} 
		}
		return null;	
	}
	
	def Object getValue(block b, number num) {
		if (num.number.integer != null) {
			return Integer.valueOf(num.number.integer);
		} else if (num.number.real != null) {
			return Double.valueOf(num.number.real);
		}
		return null;
	}
	
	def boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def Object getValue(block b, constant const) {
		var Object value = null;
		if (const.name != null) {
			var variable = search(variables.get(b), new Variable(const.name));
			value = variable.getValue;
		} else if (const.number != null) {
			value = getValue(b, const.number);
		} else if (const.string != null) {
			value = const.string;
		} else if (const.boolLiteral != null) {
			value = Boolean.valueOf(const.boolLiteral);
		} else if (const.nil != null) {
			value = null;
		}
		if (const.opterator != null) {
			if (isNumeric(value) && const.opterator.equals("-")) {
				return - Double.parseDouble(value.toString);
			}
		}
		return value;
	}
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T element, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(element);
	}
	 
	def <T extends Element> inheritElement(block b, T element, Map<block, Set<T>> container) {
		if (b.abstraction != null) {
			if (b.abstraction.procedures != null) {
				for (abstraction_declaration procedure : b.abstraction.procedures) {
					addElementToAbstraction(procedure, element, container);
				}
			}
			if (b.abstraction.functions != null) {
				for (abstraction_declaration function : b.abstraction.functions) {
					addElementToAbstraction(function, element, container);
					if (container == variables) { 
						variables.get(function.block).add(new Variable(function.heading.name, getType(b, function.heading.returnType), false, ElementType.FUNCTION_RETURN));
					}
				}
			}
		}
	} 
	 
	def <T extends Element> addElement(block b, T element, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == types) {
			var type = element as Type;
			elementFound = searchByName(types.get(b), type) as T;  
		} else {
			elementFound = search(container.get(b), element);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (element.type == elementFound.type) { 
				insertError(errorSection, element.type + " cannot be redeclared.", ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, "Identifier reserved for function return.", ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, "Identifier is already being used by a " + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			//container.get(b).remove(elementFound);
			container.get(b).add(element);
			var inheritedElement = element.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(b, inheritedElement, container);
		}
	}
	
	def getParameters(block b, abstraction_heading heading) {
		var parameters = new HashSet<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.names) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.names) {
							var parameter = new Variable(valName, getType(b, value.type), false, ElementType.PARAMETER);
							addElement(b, parameter, variables, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variables); 
		var parameters = getParameters(decl.block, heading);
		var forward = decl.forward;
		var returnType = heading.returnType;
		if (returnType != null) {  
			if (search(types.get(b), new Type(returnType)) == null) {
				insertError(heading, "Undefined type.", ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RETURN_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			}
			addElement(b, new Function(name, forward, parameters, forward, getType(b, returnType)), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
		} else {
			addElement(b, new Procedure(name, forward, parameters, forward), abstractions, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	 
	def checkAbstractionRedeclaration(block b) {
		if (b.abstraction != null) {
			clear(b, ElementType.FUNCTION, abstractions); 
			clear(b, ElementType.PROCEDURE, abstractions); 
			var abstraction = b.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, types);
		if (b.type != null) {
			for (type_definition t : b.type.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).realType), types, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variables);
		if (b.constant != null) {
			for (constant_definition const : b.constant.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, ElementType.CONSTANT, getValue(b, const.const)), variables, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variables);
		if (b.variable != null) {
			for (variable_section section : b.variable.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, ElementType.VARIABLE), variables, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variables.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, "Variable was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, "Constants cannot be assigned.", ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(abstractions.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : abstractions.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, "Wrong number of arguments. It expected " + p.parameters.size + " received " + proc.parameters.size + " arguments.", ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, "Incompatible types of arguments. It expected " + p.parameters + " received " + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, "Function was not declared.", ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, "Procedures calls are not allowed in an expression.", ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variables.containsKey(b)) {
				var v = search(variables.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, "Variable not initialized.", ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).realType.toLowerCase.equals("boolean")) {
				insertError(f, "Cannot convert " + getType(b, f.not) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).realType.toLowerCase.equals("boolean")) {
					insertError(t, "Cannot convert " + getType(b, f) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, "Cannot convert " + getType(b, f) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, "Invalid operator for boolean.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, "Only numeric types are allowed in this expression.", ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).realType.toLowerCase.equals("boolean")) {
								insertError(s, "Cannot convert " + getType(b, t) + " to boolean.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, "Cannot convert " + getType(b, t) + " to numeric.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, "Only numeric types are allowed.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variables.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, "Constant was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, "Only constants are allowed.", ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
			}
		}
	}
	
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, "Cannot convert type " + expressionType + " to " + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variables.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			} else if (simple.function_noargs != null) {
				if (search(abstractions.get(b), new Procedure(simple.function_noargs, new HashSet<Variable>())) != null) {
					removeError(simple, ErrorType.NOT_DECLARATION); 
				} else {
					insertError(simple, "Procedure was not declared.", ErrorType.NOT_DECLARATION, PascalPackage.Literals.SIMPLE_STATEMENT__FUNCTION_NOARGS);
				}
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			if (structured.compound != null) {
				var compound = structured.compound; 
				checkStatements(b, compound.sequence); 
			} else if (structured.repetitive != null) {
				var repetitive = structured.repetitive;	
				if (repetitive.whileStmt != null) {
					checkExpression(b, repetitive.whileStmt.expression);
					checkStatement(b, repetitive.whileStmt.statement);
				} else if (repetitive.repeatStmt != null) {
					checkStatements(b, repetitive.repeatStmt.sequence);
					checkExpression(b, repetitive.repeatStmt.expression);
				} else if (repetitive.forStmt != null) {
					checkVariable(b, repetitive.forStmt.assignment.variable, true);
					checkExpression(b, repetitive.forStmt.expression);
					checkStatement(b, repetitive.forStmt.statement);
				}
			} else if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).realType.toLowerCase.equals("boolean")) {
						insertError(ifStmt, "Only booleans are allowed inside a condition.", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} else if (conditional.caseStmt != null) {
					var caseStmt = conditional.caseStmt;
					checkExpression(b, caseStmt.expression);
					var exprType = getType(b, caseStmt.expression);
					for (case_limb limb : caseStmt.cases) {
						checkStatement(b, limb.statement);
						for (constant c : limb.cases.constants) {
							checkConstant(b, c);
						}
						var limbType = getType(b, limb);
					}
				} 
			} else if (structured.withStmt != null) {
				var withStmt = structured.withStmt;
				for (variable v : withStmt.variables) {
					checkVariable(b, v, false);
				}
				checkStatement(b, withStmt.statement);
			}
		}
	}
	
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	@Check
	def runCheckes(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b);
	}
	
	@Check
	def showError(EObject obj) {
		if (errorList.containsKey(obj)) {
			for (Error err : errorList.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	
}
<<<
Document event: offset: 12447, length: 0, timestamp: 5568
text:>b<


!SESSION 2015-03-08 09:55:56.901 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.dsl.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.dsl.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 09:57:31.427
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\dell'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 10:08:19.041
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/validation/AbstractPascalValidator.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 59 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 10:08:19.049
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11268)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11240)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9660)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.beginToCompile(CompilationUnitResolver.java:210)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:857)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 10:08:19.074
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/validation/AbstractPascalValidator.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 57 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 10:08:19.077
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10070)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:756)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:872)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-08 10:08:19.100
!MESSAGE File not found: '/org.xtext.example.Pascal/src-gen/org/xtext/example/pascal/validation/AbstractPascalValidator.java'
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 55 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-03-08 10:08:19.103
!MESSAGE File not found: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java.
!STACK 0
java.io.FileNotFoundException: C:\Users\dell\workspace\Pascal\org.xtext.example.Pascal\src-gen\org\xtext\example\pascal\validation\AbstractPascalValidator.java (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.jdt.internal.core.util.Util.getResourceContentsAsCharArray(Util.java:1188)
	at org.eclipse.jdt.internal.core.CompilationUnit.getContents(CompilationUnit.java:649)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:881)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:795)
	at org.eclipse.jdt.core.dom.ASTParser.createBindings(ASTParser.java:1054)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.resolveBindings(JdtBasedTypeFactory.java:434)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:389)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 10:08:19.197
!MESSAGE org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror  - Error initializing type java:/Objects/org.xtext.example.pascal.validation.AbstractPascalValidator

!STACK 0
java.lang.IllegalStateException: Could not create binding for 'org.xtext.example.pascal.validation.AbstractPascalValidator' in context of project 'org.xtext.example.Pascal'.
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:400)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:449)
	at org.eclipse.xtext.common.types.access.jdt.JdtBasedTypeFactory.createType(JdtBasedTypeFactory.java:1)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeMirror.initialize(JdtTypeMirror.java:52)
	at org.eclipse.xtext.common.types.access.TypeResource.doLoad(TypeResource.java:119)
	at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1518)
	at org.eclipse.xtext.common.types.access.TypeResource.load(TypeResource.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.createResourceAndFindType(JdtTypeProvider.java:209)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectTypeInJavaProject(JdtTypeProvider.java:192)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindObjectType(JdtTypeProvider.java:161)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findObjectType(JdtTypeProvider.java:147)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.doFindTypeByName(JdtTypeProvider.java:105)
	at org.eclipse.xtext.common.types.access.jdt.JdtTypeProvider.findTypeByName(JdtTypeProvider.java:114)
	at org.eclipse.xtext.common.types.xtext.AbstractTypeScope.getSingleElement(AbstractTypeScope.java:59)
	at org.eclipse.xtend.core.scoping.RecordingTypeScope.getSingleElement(RecordingTypeScope.java:35)
	at org.eclipse.xtend.core.scoping.TypeScopeWithWildcardImports.getSingleElement(TypeScopeWithWildcardImports.java:52)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.AbstractKnownTypesScope.getSingleElement(AbstractKnownTypesScope.java:42)
	at org.eclipse.xtend.core.scoping.PrimitiveAwareScope.getSingleElement(PrimitiveAwareScope.java:39)
	at org.eclipse.xtend.core.scoping.CachingTypeScope.getSingleElement(CachingTypeScope.java:40)
	at org.eclipse.xtext.linking.impl.DefaultLinkingService.getLinkedObjects(DefaultLinkingService.java:120)
	at org.eclipse.xtext.linking.lazy.LazyLinkingResource.getEObject(LazyLinkingResource.java:248)
	at org.eclipse.xtext.xbase.resource.BatchLinkableResource.getEObject(BatchLinkableResource.java:106)
	at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.getEObject(ResourceSetImpl.java:223)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:199)
	at org.eclipse.emf.ecore.util.EcoreUtil.resolve(EcoreUtil.java:259)
	at org.eclipse.emf.ecore.impl.BasicEObjectImpl.eResolveProxy(BasicEObjectImpl.java:1473)
	at org.eclipse.xtext.common.types.impl.JvmTypeReferenceImplCustom.eResolveProxy(JvmTypeReferenceImplCustom.java:37)
	at org.eclipse.xtext.common.types.impl.JvmParameterizedTypeReferenceImpl.getType(JvmParameterizedTypeReferenceImpl.java:111)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.initialize(XtendJvmModelInferrer.java:336)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer$3.run(XtendJvmModelInferrer.java:229)
	at org.eclipse.xtend.core.jvmmodel.XtendJvmModelInferrer.infer(XtendJvmModelInferrer.java:175)
	at org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.installDerivedState(JvmModelAssociator.java:358)
	at org.eclipse.xtext.resource.DerivedStateAwareResource.installDerivedState(DerivedStateAwareResource.java:159)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.postParse(XtextDocumentReconcileStrategy.java:169)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.doReconcile(XtextDocumentReconcileStrategy.java:146)
	at org.eclipse.xtext.ui.editor.reconciler.XtextDocumentReconcileStrategy.reconcile(XtextDocumentReconcileStrategy.java:65)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.doRun(XtextReconciler.java:413)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.access$3(XtextReconciler.java:393)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:334)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler$1.process(XtextReconciler.java:1)
	at org.eclipse.xtext.util.concurrent.IUnitOfWork$Void.exec(IUnitOfWork.java:36)
	at org.eclipse.xtext.ui.editor.model.XtextDocument$XtextDocumentLocker.modify(XtextDocument.java:418)
	at org.eclipse.xtext.ui.editor.model.XtextDocument.internalModify(XtextDocument.java:131)
	at org.eclipse.xtext.ui.editor.reconciler.XtextReconciler.run(XtextReconciler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.apache.log4j 4 0 2015-03-08 10:08:19.219
!MESSAGE org.eclipse.xtext.common.types.access.impl.AbstractClassMirror  - resource is empty: java:/Objects/org.xtext.example.pascal.validation.AbstractPascalValidator

